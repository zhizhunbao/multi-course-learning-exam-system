# CST8503 作业2：情境演算中的猴子与香蕉

---

CST8503 作业 2 —— 情境演算下的猴子和香蕉问题

## 概述

著名的猴子与香蕉问题有许多变体、解决方案和实现方式。本次作业的目的，是通过将情境演算与 Prolog 应用于该问题的一个具体版本，从而提升你在知识表示、逻辑编程与规划方面的技能。

完成本次作业后，你将能够在 Prolog 程序中利用以下情境演算与 Prolog 概念来解决规划问题：

- 情境演算的公理化描述
- 为领域识别动作集合
- 为领域识别流变命题（fluents）
- 为领域编写前提条件公理
- 为领域编写后继状态公理
- 将情境演算公理化描述转换为 Prolog 子句
- 实现并调试 Prolog 子句以求解规划问题

### 通俗概述

- 你将练习如何用逻辑而不是自然语言来描述一个小世界的运作方式。
- 你会编写 Prolog 代码，列出猴子能够执行的动作，以及每个动作之后哪些事实成立。
- 最终，你应能熟练使用逻辑规则，帮助程序搜索出一条可达成目标的计划。

## 猴子与香蕉问题

在本次作业中，我们采用以下这个确切版本的猴子与香蕉问题：

- 世界中有一只猴子、一串香蕉（也可以看作一个香蕉）、以及一个箱子；
- 初始状态下，猴子、箱子和香蕉分别位于不同的位置：位置 1、位置 2 和位置 3；
- 香蕉挂得太高，猴子无法直接够到，但如果猴子爬上箱子，它就能抓到香蕉；
- 我们将猴子视作一个具有以下基本功能的机器人：
  - 猴子可以走到某个指定位置；
  - 猴子可以把箱子推到某个指定位置；
  - 猴子可以爬上或爬下箱子；
  - 如果条件满足，猴子可以抓住香蕉；

猴子需要规划一个动作序列，使其达到目标：让猴子拿到香蕉。

### 通俗问题描述

- 想象一个谜题：猴子需要把箱子搬到香蕉下面，爬上去并把香蕉拿到手。
- 猴子能走动、推箱子、爬上/爬下箱子，并在准备就绪时抓香蕉。
- 你的任务是将这些能力清晰描述，让计算机能够搜索到正确的动作序列。

## 世界状态

仔细阅读上面的世界描述。在当前阶段，我们要思考如何使用流变命题（带情境参数的谓词）来表示这个小世界中哪些事实为真。

哪些流变命题足以完整表达这个世界的状态？想想在任意时刻可以对世界提出哪些问题。例如，如果有人问：“猴子在什么位置？”，你的流变命题能否给出回答？请专注于与描述相关的问题。例如，“猴子多重？”或者“猴子是什么颜色？”与当前问题无关，无需考虑。

目标状态在你的流变命题中如何表示？换句话说，哪些流变命题（或命题组合）能够表明目标是否达成？

请将你确定的流变命题以 Prolog 记号写在一个 Prolog 程序文件中。

并在注释中说明：这些流变命题中，哪些表示目标状态。

### 通俗状态说明

- 列出能够回答关键问题的事实，如“猴子在哪？”、“猴子是否拿到香蕉？”等。
- 只包含解决该谜题所需的事实；像颜色或重量这类信息无需出现。
- 清晰指出哪些事实（或事实组合）表示目标达成，例如“has_bananas(y,S)”表示猴子在情境 S 中拥有香蕉。

## 动作：世界如何变化

现在我们考虑猴子世界的状态如何变化。换言之，这个世界中有哪些相关动作？我们只关注猴子（机器人）能做的事，因为描述中香蕉和箱子不能主动执行动作。

请在你的 Prolog 程序的注释中写出该世界的动作集合。

### 通俗动作说明

- 列出猴子能够执行的几个动作：走动、推箱子、爬上/下、抓香蕉。
- 每个动作都应是猴子在该谜题中能够实际执行的行为。
- 将它们写成 Prolog 事实或注释，让程序知道允许的动作。

## 前提条件公理

本节我们要考虑：在什么情境下每个动作是可执行的？换句话说，各个动作的前提条件是什么？

请在你的程序中，为该领域的每个动作写出前提条件公理。

### 通俗前提说明

- 对每个动作说明其执行条件。例如：要推箱子，猴子必须与箱子在同一位置。
- 这些规则可以阻止不可能发生的动作，如猴子不在箱子旁却尝试推箱子。
- 将每条规则写成 Prolog 子句，确保程序在选择动作之前检验这些条件。

## 后继状态公理

在这里，我们关注每次动作发生后，状态如何变化（或保持不变）。

请在你的 Prolog 程序中，为领域内的每个流变命题写出后继状态公理。

### 通俗后继说明

- 描述每个事实在动作发生后如何变化（或保持原状）。
- 例如：执行“走到位置 2”动作后，猴子的位置信息更新为位置 2。
- 后继状态公理帮助我们在动作序列中逐步跟踪世界状态的变化。

## 规划目标

完成并运行实现该领域的 Prolog 程序，其中包含一个用于执行规划的 Prolog 过程，以达成目标：

```prolog
% plan(g(S),S) 在 g(S) 为真时成立，其中 g(S) 是关于情境 S 的目标公式，S 是动作历史（即计划）

plan(Goal,Plan):-bposs(Plan),Goal.

% bposs(S) 在 S 是一个按序列长度由短到长遍历的“可能动作序列”时为真

bposs(S) :- tryposs([],S).

% tryposs(S,S) 在 S 是一个按最短序列优先的可能动作序列（即对可能动作序列进行广度优先搜索）时为真

tryposs(S,S) :- poss(S).

tryposs(X,S) :- tryposs([_|X],S).
```

### 通俗规划说明

- `plan/2` 会尝试不同的动作序列，直到目标事实成立。
- `bposs/1` 和 `tryposs/2` 按照“最短先行”的策略枚举可能的动作序列。
- 搜索持续进行，直到找到一条能让猴子最终拿到香蕉的动作序列。

## 演示

提交你的 Prolog 程序文件（使用“.prolog”扩展名，以避免“.pl”带来的兼容性问题）至 Brightspace。

然后向实验课教师演示你的程序可以输出一条让猴子抓到香蕉的计划，即存在某个动作序列 S，使得 `has_bananas(y,S)` 为真。

同时准备好解释你的解决方案并回答相关问题。

### 通俗演示提示

- 提交你编写的 Prolog 文件，以便教师审阅逻辑。
- 准备好运行程序，展示它能找到让猴子拿到香蕉的计划。
- 确保你能解释代码执行的步骤，并回答可能的追问。
