:- encoding(utf8).
% 积木世界规划系统（使用情境演算，SWI-Prolog）
% ------------------------------------------------------
% 本程序可以自动规划如何将积木从初始状态移动到目标状态。
% 主要组件：
%   - 积木和位置定义
%   - 初始状态（所有积木的起始位置）
%   - 移动动作规则（何时可以移动积木）
%   - 状态变化规则（移动后积木位置如何变化）
%   - 自动规划算法（找到最短移动序列）
%
% ============================================================================
% Prolog 核心概念：结构、谓词和事实
% ============================================================================
%
%  - 结构 = 数据对象（例如，block(a) = "积木 a"）
%  - 谓词 = 查询模板（例如，clear(什么, 什么状态) = "在什么状态下什么位置是空的"）
%  - 事实 = 具体答案（例如，clear(block(c), []) = "在初始状态下积木 c 的顶部是空的"）
%
% 关于 [] 参数（状态参数）：
%
% 为什么需要状态参数？
%  - 同一个事实在不同状态下可能不同（例如，移动积木后，位置会改变）
%  - 状态参数允许我们查询"在特定状态下"的事实
%  - 通过递归传递状态，程序可以跟踪每一步的状态变化
%
% 示例：
%  - clear(block(c), []) 表示"在初始状态下积木 c 的顶部是空的"
%  - clear(block(c), [move(block(c), block(a), location(2))]) 表示"执行移动动作后，积木 c 的顶部是否为空"
%
% ============================================================================

% 非连续声明，允许初始状态事实和后继状态公理
% 分离以便更好地组织代码
:- discontiguous on/3.
:- discontiguous clear/2.

% ============================================================================
% 初始状态：积木的起始位置
% ============================================================================

% 系统中有三个积木：a, b, c
block_exists(block(a)).
block_exists(block(b)).
block_exists(block(c)).

% 系统中有四个位置：1, 2, 3, 4
location_exists(location(1)).
location_exists(location(2)).
location_exists(location(3)).
location_exists(location(4)).

% 哪些积木或位置是空的（可以在上面放置东西）
% 积木 c 和 b 的顶部是空的，位置 2 和 4 是空的
clear(block(c), []).
clear(block(b), []).
clear(location(2), []).
clear(location(4), []).

% 积木位置：
% - 积木 a 在位置 1 上
% - 积木 b 在位置 3 上
% - 积木 c 在积木 a 上（所以 a 的顶部不是空的）
on(block(a), location(1), []).
on(block(b), location(3), []).
on(block(c), block(a), []).

% ============================================================================
% 可能性公理（动作前提）：何时可以移动积木
% ============================================================================
% 本节定义可能性公理（动作前提）：执行"移动积木"动作必须满足的条件。
%
% 注意：move(Block, From, To) 是一个结构，表示"将积木 Block 从 From 移动到 To"
%      move 不需要单独定义；它在这里通过 poss 规则定义
%      这些规则指定"何时可以执行此动作"
%
% 关于参数 [move(Block, From, To) | S]：
%   - 这是 Prolog 列表语法，表示一个"动作序列"（计划）
%   - 格式：[动作 | 动作历史]
%   - move(Block, From, To) 是列表的头，表示"要执行的最新动作"
%   - S 是列表的尾，表示"之前执行的动作序列"（历史）
%   - 示例：[move(a,1,2), move(b,3,1)] 表示：
%            首先执行 move(b,3,1)（将 b 从位置 3 移动到位置 1）
%            然后执行 move(a,1,2)（将 a 从位置 1 移动到位置 2）
%   - 在规划问题中，此列表表示从右到左的时间顺序（最新动作在左边）

% 空状态（初始状态）始终有效
poss([]).

% 要执行动作"将积木 Block 从 From 移动到 To"，必须满足以下所有条件：
% 1. 前一个状态 S 必须有效（可以执行前一个动作序列）
% 2. Block 必须是一个真实存在的积木
% 3. Block 的顶部必须是空的（不能有其他积木在上面，否则无法拿起）
% 4. Block 当前必须在 From 位置（不能移动不在那里的积木）
% 5. Block 不能移动到自己的位置（防止无意义的移动）
% 6. From 必须是有效的位置或积木
% 7. To 必须是有效的位置或积木
% 8. To 的顶部必须是空的（目标位置必须有空间放置积木）
poss([move(Block,From,To)|S]):-
    poss(S),
    block_exists(Block),
    clear(Block,S),
    (location_exists(To) ; block_exists(To)),
    Block \= To,
    clear(To,S),
    (location_exists(From);block_exists(From)),
    on(Block,From,S).



% ============================================================================
% 状态变化规则：移动后积木位置如何变化
% ============================================================================
% 本节定义执行移动动作后积木世界如何变化。

% 情况 1：从 X 移走某物 -> X 变为空的
%   条件 1：poss([move(Z,X,Y) | S]) - 此移动动作必须有效
clear(X,[move(Z,X,Y)|S]):-
    poss([move(Z,X,Y)|S]).

% 情况 2：其他动作，X 的状态保持不变
%   条件 1：poss([A | S]) - 动作 A 必须有效
%   条件 2：A \= move(_, _, X) - 排除将某物移动到 X 上的动作
%   条件 3：clear(X, S) - X 之前是空的，动作 A 不影响 X，所以 X 仍然为空
clear(X, [A | S]) :-
    poss([A | S]),
    A \= move(_, _, X),
    clear(X, S).

% 情况 3：X 被移动到 Y 上 -> X 在 Y 上
%   条件 1：poss([move(X, Z, Y) | S]) - 此移动动作必须有效
on(X, Y, [move(X, Z, Y) | S]) :-
    poss([move(X, Z, Y) | S]).

% 情况 4：其他动作，关系"X 在 Y 上"保持不变
%   条件 1：poss([A | S]) - 动作 A 必须有效
%   条件 2：A \= move(X, Y, _) - 排除将 X 从 Y 移走的动作
%   条件 3：on(X, Y, S) - X 之前在 Y 上，动作 A 不影响此关系，所以保持不变
on(X, Y, [A | S]) :-
    poss([A | S]),
    A \= move(X, Y, _),
    on(X, Y, S).


% ============================================================================
% 自动规划：找到最短移动序列
% ============================================================================
% 此代码实现自动规划功能。当您提供目标时，
% 程序将自动尝试所有
% 可能的移动序列，从最短的开始，直到找到一个
% 能够实现目标的序列。

plan(Goal, Plan) :-
    bposs(Plan),
    call(Goal).

bposs(S) :-
    tryposs([], S).

tryposs(S, S) :-
    poss(S).

tryposs(X, S) :-
    tryposs([_ | X], S).

% ============================================================================
% 使用示例
% ============================================================================
%
% 示例 1：查询初始状态
%   ?- on(block(c), block(a), []).
%   true.
%
%   ?- clear(block(c), []).
%   true.
%
% 示例 2：查询移动后的状态
%   ?- on(block(c), location(2), [move(block(c), block(a), location(2))]).
%   true.
%
%   ?- clear(block(a), [move(block(c), block(a), location(2))]).
%   true.
%
% 示例 3：检查移动是否可行
%   ?- poss([move(block(c), block(a), location(2))]).
%   true.
%
% 示例 4：规划以实现目标状态
%   ?- plan(on(block(c), location(2), Plan), Plan).
%   Plan = [move(block(c), block(a), location(2))] ;
%   Plan = [move(block(c), block(a), location(2)), move(block(a), location(1), location(2))] ;
%   ...
%
%   这将找到将积木 c 放到位置 2 的最短计划（第一个解）。
%
% 示例 5：规划堆叠积木
%   ?- plan(on(block(b), block(c), Plan), Plan).
%   Plan = [move(block(c), block(a), location(2)), move(block(b), location(3), block(c))] ;
%   ...
%
%   这找到将积木 b 放到积木 c 上的计划。

