{
  "courseId": "cst8503",
  "title": "知识表示与推理",
  "description": "知识表示方法和推理技术",
  "lastUpdated": "2025-10-16",
  "experiments": [
    {
      "id": 1,
      "title": "Prolog基础编程",
      "description": "学习Prolog语言的基本语法和编程技巧",
      "order": 1,
      "instructions": [
        "定义事实和规则",
        "编写简单的查询",
        "使用列表操作",
        "实现递归规则",
        "测试程序逻辑"
      ],
      "hints": [
        "事实以小写字母开头",
        "规则使用 :- 符号",
        "变量以大写字母开头",
        "使用递归处理列表"
      ],
      "template": "% 在这里编写你的Prolog代码\n\n% 1. 定义事实\n% parent(john, mary).\n% parent(mary, tom).\n\n% 2. 定义规则\n% grandparent(X, Y) :- parent(X, Z), parent(Z, Y).\n\n% 3. 列表操作\n% member(X, [X|_]).\n% member(X, [_|T]) :- member(X, T).\n\n% 4. 递归规则\n% length([], 0).\n% length([_|T], N) :- length(T, M), N is M + 1.\n\n% 查询示例:\n% ?- grandparent(john, tom).\n% ?- member(3, [1,2,3,4]).",
      "testCases": [
        {
          "description": "测试事实查询",
          "input": { "query": "parent(john, mary)" },
          "expected": "true"
        },
        {
          "description": "测试规则推理",
          "input": { "query": "grandparent(john, tom)" },
          "expected": "true"
        }
      ]
    },
    {
      "id": 2,
      "title": "专家系统设计",
      "description": "设计一个简单的专家系统",
      "order": 2,
      "instructions": [
        "定义知识库",
        "编写推理规则",
        "实现查询接口",
        "测试系统功能",
        "优化推理效率"
      ],
      "hints": [
        "使用规则表示知识",
        "实现前向推理",
        "处理不确定性",
        "提供解释功能"
      ],
      "template": "% 专家系统 - 医疗诊断\n\n% 症状定义\n% symptom(fever).\n% symptom(cough).\n% symptom(headache).\n\n% 疾病定义\n% disease(cold).\n% disease(flu).\n% disease(migraine).\n\n% 诊断规则\n% diagnose(cold) :- symptom(fever), symptom(cough).\n% diagnose(flu) :- symptom(fever), symptom(cough), symptom(headache).\n% diagnose(migraine) :- symptom(headache), not(symptom(fever)).\n\n% 查询示例:\n% ?- diagnose(X).",
      "testCases": [
        {
          "description": "测试诊断功能",
          "input": { "symptoms": ["fever", "cough"] },
          "expected": "cold"
        },
        {
          "description": "测试多症状诊断",
          "input": { "symptoms": ["fever", "cough", "headache"] },
          "expected": "flu"
        }
      ]
    },
    {
      "id": 3,
      "title": "情境演算与规划",
      "description": "使用Prolog实现情境演算和规划系统",
      "order": 3,
      "instructions": [
        "理解情境演算的基本概念",
        "实现前提条件公理",
        "编写后继状态公理",
        "实现广度优先规划算法",
        "测试积木世界规划问题"
      ],
      "hints": [
        "情境用列表表示：[]表示初始情境",
        "流元必须包含情境参数",
        "前提条件检查行动是否可执行",
        "后继状态公理描述行动效果",
        "广度优先搜索避免无限循环"
      ],
      "template": "% 情境演算与规划 - 积木世界\n\n% ===== 对象定义 =====\nblock_exists(block(a)).\nblock_exists(block(b)).\nblock_exists(block(c)).\n\nlocation_exists(location(1)).\nlocation_exists(location(2)).\nlocation_exists(location(3)).\nlocation_exists(location(4)).\n\n% ===== 初始状态 =====\n% 初始情境用空列表 [] 表示\nclear(location(2), []).\nclear(location(4), []).\nclear(block(b), []).\nclear(block(c), []).\n\non(block(a), location(1), []).\non(block(b), location(3), []).\non(block(c), block(a), []).\n\n% ===== 前提条件公理 =====\n% 定义何时可以执行 move(Block,From,To) 行动\nposs([move(Block,From,To)|S]) :-\n    block_exists(Block),\n    clear(Block, S),\n    (location_exists(To) ; block_exists(To)),\n    Block \\= To,\n    clear(To, S),\n    (location_exists(From) ; block_exists(From)),\n    on(Block, From, S).\n\n% ===== 后继状态公理 =====\n% clear(X,S) - 位置X在情境S中是清空的\n\n% 规则1：如果从X移走某物，X变为清空\nclear(X, [move(Z,X,Y)|S]) :-\n    poss([move(Z,X,Y)|S]).\n\n% 规则2：如果X已经清空且没有东西移动到X上，X保持清空\nclear(X, [A|S]) :-\n    poss([A|S]),\n    A \\= move(_,_,X),\n    clear(X, S).\n\n% on(X,Y,S) - 积木X在情境S中位于位置Y上\n\n% 规则1：如果将X移动到Y，则X在Y上\non(X, Y, [move(X,Z,Y)|S]) :-\n    poss([move(X,Z,Y)|S]).\n\n% 规则2：如果X已经在Y上且没有从Y移走，X保持在Y上\non(X, Y, [A|S]) :-\n    poss([A|S]),\n    A \\= move(X,Y,_),\n    on(X, Y, S).\n\n% ===== 规划算法 =====\n% 广度优先规划\nplan(Goal, Plan) :-\n    bposs(Plan),\n    Goal.\n\nbposs(S) :-\n    tryposs([], S).\n\n% 基础情况：S是一个有效的计划\ntryposs(S, S) :-\n    poss(S).\n\n% 递归情况：尝试增加一个行动\ntryposs(X, S) :-\n    tryposs([_|X], S).\n\n% ===== 查询示例 =====\n% 1. 测试单步移动\n% ?- on(block(b), location(2), S).\n% 预期结果: S = [move(block(b), location(3), location(2))]\n\n% 2. 测试清空位置\n% ?- clear(location(3), S).\n% 预期结果: S = [move(block(b), location(3), location(2))] 或其他有效计划\n\n% 3. 测试多步规划\n% ?- plan(on(block(a), block(b), S), S).\n% 预期结果: 一个将block(a)移到block(b)上的行动序列\n\n% 4. 测试复杂目标\n% ?- plan((on(block(a), block(b), S), on(block(b), block(c), S)), S).\n% 预期结果: 构建塔 c-b-a 的行动序列",
      "testCases": [
        {
          "description": "测试单步移动 - 将block(b)移到location(2)",
          "input": { "query": "on(block(b), location(2), S)" },
          "expected": "S = [move(block(b), location(3), location(2))]"
        },
        {
          "description": "测试清空位置 - 清空location(3)",
          "input": { "query": "clear(location(3), S)" },
          "expected": "S = [move(block(b), location(3), _)]"
        },
        {
          "description": "测试前提条件检查 - 不能移动有东西在上面的积木",
          "input": {
            "query": "poss([move(block(a), location(1), location(2))|[]])"
          },
          "expected": "false"
        },
        {
          "description": "测试后继状态 - 移动后位置变为清空",
          "input": {
            "query": "clear(block(a), [move(block(c), block(a), location(2))])"
          },
          "expected": "true"
        },
        {
          "description": "测试规划算法 - 找到将block(c)移到location(2)的计划",
          "input": { "query": "plan(on(block(c), location(2), S), S)" },
          "expected": "S = [move(block(c), block(a), location(2))]"
        }
      ],
      "references": [
        {
          "title": "情境演算讲义",
          "path": "/pdfs/knowledge-reasoning/Course 10/CST8503_10_SituationCalculus.pdf"
        },
        {
          "title": "规划讲义",
          "path": "/pdfs/knowledge-reasoning/Course 8 Planning/CST8503_08_Planning.pdf"
        },
        {
          "title": "积木世界规划代码",
          "path": "/pdfs/knowledge-reasoning/Lab5 KR Blocks/blocks_world_planning.pl"
        },
        {
          "title": "情境演算与规划考试题库",
          "path": "/data/questions/cst8503/situation-calculus-planning-questions.md"
        }
      ]
    }
  ]
}
