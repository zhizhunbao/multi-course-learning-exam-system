{
  "courseId": "cst8503",
  "chapterId": "chapter2-prolog-basics",
  "title": "Prolog基础",
  "description": "Prolog基础相关题目",
  "totalQuestions": 20,
  "lastUpdated": "2025-10-16",
  "language": "en",
  "questions": [
    {
      "id": 1,
      "type": "multiple-choice",
      "question": "What logical system is Prolog based on?",
      "options": [
        "Propositional Logic",
        "Predicate Logic",
        "Modal Logic",
        "Temporal Logic"
      ],
      "correctAnswer": 1,
      "explanation": "Prolog is based on predicate logic, specifically Horn clause logic.",
      "difficulty": "easy",
      "tags": ["chapter2-prolog-basics"],
      "points": 1
    },
    {
      "id": 7,
      "type": "multiple-choice",
      "question": "What are the basic components of a Prolog program?",
      "options": [
        "Functions and classes",
        "Facts and rules",
        "Variables and constants",
        "Loops and conditions"
      ],
      "correctAnswer": 1,
      "explanation": "A Prolog program is a set of statements called clauses, which are facts and rules.",
      "difficulty": "easy",
      "tags": ["chapter2-prolog-basics"],
      "points": 1
    },
    {
      "id": 8,
      "type": "multiple-choice",
      "question": "What are the two contexts in Prolog?",
      "options": [
        "Compilation and execution",
        "Writing programs and running programs",
        "Debugging and testing",
        "Input and output"
      ],
      "correctAnswer": 1,
      "explanation": "Prolog has two contexts: writing Prolog programs (|: prompt) and running Prolog programs (?- prompt).",
      "difficulty": "easy",
      "tags": ["chapter2-prolog-basics"],
      "points": 1
    },
    {
      "id": 9,
      "type": "multiple-choice",
      "question": "What is the command to load program files in Prolog?",
      "options": ["load", "import", "consult", "include"],
      "correctAnswer": 2,
      "explanation": "In Prolog, use the consult command to load program files, or use list notation [filename].",
      "difficulty": "easy",
      "tags": ["chapter2-prolog-basics"],
      "points": 1
    },
    {
      "id": 10,
      "type": "multiple-choice",
      "question": "What is the closed world assumption in Prolog?",
      "options": [
        "The world is finite",
        "Only stated things are true",
        "All things are known",
        "The world is open"
      ],
      "correctAnswer": 1,
      "explanation": "The closed world assumption means only the things we state and their logical implications are true.",
      "difficulty": "easy",
      "tags": ["chapter2-prolog-basics"],
      "points": 1
    },
    {
      "id": 11,
      "type": "multiple-choice",
      "question": "What is the scope of variables in Prolog?",
      "options": [
        "Global scope",
        "Single clause",
        "Entire program",
        "Single predicate"
      ],
      "correctAnswer": 1,
      "explanation": "The scope of variable names in Prolog is a single clause.",
      "difficulty": "easy",
      "tags": ["chapter2-prolog-basics"],
      "points": 1
    },
    {
      "id": 12,
      "type": "multiple-choice",
      "question": "What is the correct syntax for Prolog rules?",
      "options": ["if P then Q", "P -> Q", "Q :- P", "Q if P"],
      "correctAnswer": 2,
      "explanation": "Prolog rule syntax is Q :- P, read as 'Q if P', meaning to prove Q is true, we can succeed by proving P is true.",
      "difficulty": "medium",
      "tags": ["chapter2-prolog-basics"],
      "points": 1
    },
    {
      "id": 13,
      "type": "multiple-choice",
      "question": "What does the comma ',' represent in Prolog?",
      "options": ["OR", "AND", "NOT", "IMPLIES"],
      "correctAnswer": 1,
      "explanation": "In Prolog, the comma ',' represents 'and'.",
      "difficulty": "easy",
      "tags": ["chapter2-prolog-basics"],
      "points": 1
    },
    {
      "id": 15,
      "type": "multiple-choice",
      "question": "How many syntactic forms do atoms have in Prolog?",
      "options": ["1 form", "2 forms", "3 forms", "4 forms"],
      "correctAnswer": 2,
      "explanation": "Atoms in Prolog have 3 syntactic forms: strings starting with lowercase letters, special character strings, and strings in single quotes.",
      "difficulty": "easy",
      "tags": ["chapter2-prolog-basics"],
      "points": 1
    },
    {
      "id": 16,
      "type": "multiple-choice",
      "question": "What is the anonymous variable in Prolog?",
      "options": [
        "Single underscore",
        "Uppercase X",
        "Lowercase x",
        "Question mark"
      ],
      "correctAnswer": 0,
      "explanation": "The anonymous variable in Prolog is a single underscore '_'.",
      "difficulty": "easy",
      "tags": ["chapter2-prolog-basics"],
      "points": 1
    },
    {
      "id": 17,
      "type": "multiple-choice",
      "question": "What is a structure in Prolog?",
      "options": [
        "Single value",
        "Object with multiple components",
        "Function call",
        "Variable"
      ],
      "correctAnswer": 1,
      "explanation": "A structure is an object with multiple components, such as date(17, june, 2006).",
      "difficulty": "easy",
      "tags": ["chapter2-prolog-basics"],
      "points": 1
    },
    {
      "id": 18,
      "type": "multiple-choice",
      "question": "What is the difference between matching and unification in Prolog?",
      "options": [
        "No difference",
        "Unification includes occurs check",
        "Matching is stricter",
        "Unification is looser"
      ],
      "correctAnswer": 1,
      "explanation": "Unification = matching + occurs check. The occurs check ensures one side doesn't occur within the other.",
      "difficulty": "hard",
      "tags": ["chapter2-prolog-basics"],
      "points": 1
    },
    {
      "id": 19,
      "type": "multiple-choice",
      "question": "What is the better way to represent that two things are different in Prolog?",
      "options": [
        "Use \\+ operator",
        "Use dif/2 predicate",
        "Use = operator",
        "Use != operator"
      ],
      "correctAnswer": 1,
      "explanation": "The dif/2 built-in predicate is better because it delays comparison until both variables are instantiated.",
      "difficulty": "easy",
      "tags": ["chapter2-prolog-basics"],
      "points": 1
    },
    {
      "id": 24,
      "type": "multiple-choice",
      "question": "What is the priority range for operators in Prolog?",
      "options": ["0-100", "0-1000", "1-1200", "0-1200"],
      "correctAnswer": 3,
      "explanation": "The priority range for operators in Prolog is 0-1200, with lower numbers having higher precedence.",
      "difficulty": "easy",
      "tags": ["chapter2-prolog-basics"],
      "points": 1
    },
    {
      "id": 26,
      "type": "multiple-choice",
      "question": "What operator compares if two numeric values are equal in Prolog?",
      "options": ["=", "==", "=:=", "equals"],
      "correctAnswer": 2,
      "explanation": "Use the =:= operator to compare if two numeric values are equal in Prolog, e.g., 2+5 =:= 5+2.",
      "difficulty": "easy",
      "tags": ["chapter2-prolog-basics"],
      "points": 1
    },
    {
      "id": 31,
      "type": "multiple-choice",
      "question": "Why does negation give wrong answers when involving unbound variables?",
      "options": [
        "Negation always fails",
        "Negation requires ground terms",
        "Negation is non-logical",
        "All of the above"
      ],
      "correctAnswer": 3,
      "explanation": "Negation gives wrong answers with unbound variables because it always fails, requires ground terms, and is non-logical.",
      "difficulty": "medium",
      "tags": ["chapter2-prolog-basics"],
      "points": 1
    },
    {
      "id": 32,
      "type": "multiple-choice",
      "question": "What are the three cases where order is important in Prolog?",
      "options": [
        "Recursion, arithmetic, negation",
        "Variables, constants, predicates",
        "Facts, rules, queries",
        "Head, tail, list"
      ],
      "correctAnswer": 0,
      "explanation": "The three cases where order is important in Prolog are: recursion and infinite loops, arithmetic, and negation.",
      "difficulty": "easy",
      "tags": ["chapter2-prolog-basics"],
      "points": 1
    },
    {
      "id": 35,
      "type": "coding",
      "question": "Write a Prolog program that implements the four steps of the matching algorithm. Create predicates that demonstrate: 1) Constant matching, 2) Variable instantiation, 3) Structure matching with same functor, and 4) Structure matching with different functors.",
      "correctAnswer": "% Constant matching\nequal_constants(X, X).\n\n% Variable instantiation\ninstantiate_var(X, Y) :- var(X), nonvar(Y), X = Y.\n\n% Structure matching with same functor\nmatch_structure(f(X), f(Y)) :- X = Y.\nmatch_structure(g(X,Y), g(A,B)) :- X = A, Y = B.\n\n% Structure matching with different functors (should fail)\nmatch_different(f(X), g(Y)) :- fail.\n\n% Example facts\nperson(john).\nperson(mary).\n\n% Example queries:\n% ?- equal_constants(5, 5).\n% ?- instantiate_var(X, john).\n% ?- match_structure(f(john), f(X)).",
      "explanation": "This demonstrates the four steps of Prolog's matching algorithm: constant matching, variable instantiation, structure matching with same functor, and handling different functors.",
      "difficulty": "hard",
      "tags": ["chapter2-prolog-basics"],
      "points": 3
    },
    {
      "id": 37,
      "type": "coding",
      "question": "Write a Prolog program that demonstrates procedural interpretation execution steps. Create a simple family tree with facts and rules, then write queries that show: 1) Direct fact matching, 2) Rule application with goal addition, 3) Backtracking when no match is found.",
      "correctAnswer": "% Family tree facts\nparent(john, mary).\nparent(mary, tom).\nparent(tom, lisa).\n\n% Rules\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).\n\n% Example queries demonstrating procedural interpretation:\n% ?- parent(john, mary).  % Direct fact match\n% ?- ancestor(john, tom).  % Rule application: parent(john, mary), ancestor(mary, tom)\n% ?- ancestor(john, lisa). % Multiple rule applications with backtracking\n\n% Additional facts for more complex backtracking\nparent(john, sarah).\nparent(sarah, lisa).",
      "explanation": "This demonstrates procedural interpretation: direct fact matching, rule application with goal addition to query front, and backtracking when no matches are found.",
      "difficulty": "medium",
      "tags": ["chapter2-prolog-basics"],
      "points": 2
    }
  ]
}
