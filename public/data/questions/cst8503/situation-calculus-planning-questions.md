# CST8503 情境演算与规划 - 考试题库

> **考试说明**：本题库专注于情境演算和规划主题，包含 30 道选择题、10 道填空题、简答题和 Prolog 编程题。
>
> **总分**：60 分
>
> - 选择题：30 分（每题 1 分）
> - 填空题：10 分（每题 1 分）
> - 简答题：15 分
> - Prolog 编程题：5 分

---

## 📝 第一部分：选择题

**说明**：每题 1 分，共 30 分。选择最佳答案。

### 第 1 题

**来源：情境演算 - 简介**

什么是情境演算（Situation Calculus）？

- A. 用于静态世界的二阶谓词语言
- B. 用于表示和推理动态世界的一阶谓词语言
- C. 用于创建 AI 系统的编程语言
- D. 一种机器学习算法

<details>
<summary>查看答案</summary>

**答案：B**

**解释**：情境演算是专门设计用于表示和推理动态世界的一阶谓词语言——即随着行动而随时间变化的环境。

**详细说明**：

- 由 John McCarthy 于 1963 年首次提出
- 由多伦多大学 KR 小组进一步发展（Ray Reiter、Hector Levesque）
- 与只能描述静态事实的传统逻辑不同，情境演算允许我们表达"执行行动后会发生什么"

</details>

---

### 第 2 题

**来源：情境演算 - 基本元素**

情境演算的三个基本元素是什么？

- A. 行动、状态和目标
- B. 行动、流元和情境
- C. 谓词、函数和变量
- D. 对象、关系和条件

<details>
<summary>查看答案</summary>

**答案：B**

**解释**：情境演算的三个基本元素是：

1. **行动（Actions）** - 可以在世界中执行的操作
2. **流元（Fluents）** - 描述随时间变化的世界状态的谓词
3. **情境（Situations）** - 表示已执行行动序列的行动历史

**详细说明**：

- 行动是改变世界的唯一机制
- 流元是"流动的"谓词，其真值随着行动的执行而变化
- 情境记录"发生了什么"以确定"当前状态是什么"

</details>

---

### 第 3 题

**来源：情境演算 - 情境**

在现代情境演算中，情境表示什么？

- A. 世界的当前状态
- B. 所有流元值的快照
- C. 行动历史或行动过程
- D. 要实现的目标

<details>
<summary>查看答案</summary>

**答案：C**

**解释**：在现代情境演算中，情境是行动历史——已执行的行动序列，而不是状态本身。

**详细说明**：

- **重要区别**：情境 ≠ 状态
- 状态描述"是什么"，情境描述"如何到达这里"
- 相同的状态可能通过不同的行动序列到达，但每个序列是唯一的
- 从行动历史我们可以推导当前状态，但仅从状态无法推导历史

</details>

---

### 第 4 题

**来源：情境演算 - 情境**

特殊符号 `S₀`（或 Prolog 中的 `[]`）表示什么？

- A. 所有行动后的最终情境
- B. 尚未发生任何行动的初始情境
- C. 未定义的情境
- D. 错误状态

<details>
<summary>查看答案</summary>

**答案：B**

**解释**：S₀（或 Prolog 表示法中的 `[]`）表示尚未发生任何行动的初始情境——所有行动历史的起点。

**详细说明**：

- 所有情境都使用 `do` 函数从 S₀ 构建
- 例如：`do(pick_up(b1), S₀)` 表示在初始情境上执行 pick_up
- 在 Prolog 中，我们使用空列表 `[]` 以便于操作

</details>

---

### 第 5 题

**来源：情境演算 - 情境**

情境 `do(put_down(b1), do(move(x,y), do(pick_up(b1), S)))` 应该如何阅读？

- A. 放下 b1，然后 move(x,y)，然后拿起 b1
- B. 拿起 b1，然后 move(x,y)，然后放下 b1
- C. 所有行动同时发生
- D. 顺序无关紧要

<details>
<summary>查看答案</summary>

**答案：B**

**解释**：情境从内向外阅读（从右到左）：从 S 开始，首先执行 pick_up(b1)，然后 move(x,y)，最后 put_down(b1)。

**详细说明**：

- 从外向内写，但从内向外读（像剥洋葱）
- 最内层的 `do` 是第一个行动
- 最外层的 `do` 是最后一个行动
- 在 Prolog 列表表示法中：`[put_down(b1), move(x,y), pick_up(b1)]` 从右向左读

</details>

---

### 第 6 题

**来源：情境演算 - 流元**

为什么描述世界状态的谓词被称为"流元（fluents）"？

- A. 因为它们从一个情境流向另一个情境
- B. 因为它们的真值由于行动而流动/变化
- C. 因为它们描述流体动力学
- D. 因为它们的定义很灵活

<details>
<summary>查看答案</summary>

**答案：B**

**解释**：谓词被称为"流元"是因为它们的真值随着行动的执行而流动/变化。这个名字来自拉丁语"fluere"，意思是"流动"。

**详细说明**：

- 与静态谓词（例如"2+2=4"）不同，流元是动态的
- 一个流元在一个情境中可能为真，在另一个情境中可能为假
- 例子：`on(b1,b2,s)`、`clear(b1,s)`、`holding(b3,s)`
- 所有流元必须包含情境参数作为它们的最后一个参数

</details>

---

### 第 7 题

**来源：情境演算 - 流元**

以下哪个是格式正确的流元？

- A. `on(block(b1), block(b2))`
- B. `clear(block(b1))`
- C. `holding(block(b3), s)`
- D. `move(b1, b2, b3)`

<details>
<summary>查看答案</summary>

**答案：C**

**解释**：流元必须包含情境参数。`holding(block(b3), s)` 是唯一包含情境 `s` 作为最后一个参数的选项。

**详细说明**：

- 选项 A 和 B 缺少情境参数
- 选项 D 是一个行动，不是流元
- 流元描述状态；行动描述变化

</details>

---

### 第 8 题

**来源：情境演算 - 行动模式**

在积木世界中，为什么我们使用像 `move(Block,Src,Dst)` 这样的行动模式而不是列出所有单个行动？

- A. 为了节省内存
- B. 用单个表达式表示许多单个行动
- C. 因为 Prolog 需要模式
- D. 使代码运行更快

<details>
<summary>查看答案</summary>

**答案：B**

**解释**：行动模式是一个模板，用单个表达式表示许多单个行动，使表示更简洁和通用。

**详细说明**：

- 有 3 个积木和 7 个位置（3 个积木 + 4 个位置），有 3×7×7 = 147 种可能的移动
- 一个模式 `move(Block,Src,Dst)` 涵盖所有这些
- 更易维护：当积木/位置改变时，只需更新参数
- 并非所有 147 种组合都有效；前提条件过滤哪些行动可执行

</details>

---

### 第 9 题

**来源：情境演算 - 公理**

在情境演算的上下文中，公理是什么？

- A. 需要证明的数学定理
- B. 在表示领域时我们做出的初始陈述（逻辑公式）
- C. Prolog 语法规则
- D. 系统中的错误消息

<details>
<summary>查看答案</summary>

**答案：B**

**解释**：公理是我们在描述领域时建立的基础陈述和规则——就像游戏手册中的基本规则。

**详细说明**：

- 公理不需要证明；它们作为推理的起点
- 它们描述在什么条件下可以做什么以及行动后会发生什么
- 就像机器人的操作手册，指定在该领域中遵循的规则

</details>

---

### 第 10 题

**来源：情境演算 - 前提条件公理**

前提条件公理的一般形式是什么？

- A. `Poss(A(x⃗), s) ≡ Φ(x⃗, s)`
- B. `R(y⃗, do(A(x⃗), s)) ≡ γ(y⃗, A(x⃗), s)`
- C. `do(a, s) → s`
- D. `Fluent(x, s) ⊃ Action(x)`

<details>
<summary>查看答案</summary>

**答案：A**

**解释**：前提条件公理的一般形式是 `Poss(A(x⃗), s) ≡ Φ(x⃗, s)`，它表示在情境 s 中行动 A 是可能的，当且仅当条件 Φ 满足。

**详细说明**：

- `Poss(A(x⃗), s)` 表示"在情境 s 中行动 A 是可能的"
- `≡` 表示"当且仅当"（双条件）
- `Φ(x⃗, s)` 是使用流元的逻辑公式，描述 A 何时可能
- 这防止考虑无效/不可能的行动

</details>

---

### 第 11 题

**来源：情境演算 - 前提条件公理**

在积木世界的 `move(Block,From,To)` 前提条件公理中，以下哪个条件不是必需的？

- A. 积木必须存在
- B. 积木必须是清空的
- C. 积木必须是红色的
- D. 目标必须是清空的

<details>
<summary>查看答案</summary>

**答案：C**

**解释**：积木的颜色与它是否可以被移动无关。必需的条件包括：积木存在、积木是清空的、目标存在且是清空的、积木在源位置。

**详细说明**：
必需的前提条件：

- `block_exists(Block)` - 积木必须存在
- `clear(Block,S)` - 积木必须是清空的（上面没有东西）
- `clear(To,S)` - 目标必须是清空的
- `on(Block,From,S)` - 积木必须实际在源位置
- `Block \= To` - 不能将积木移动到它自己上面

</details>

---

### 第 12 题

**来源：情境演算 - 后继状态公理**

后继状态公理描述什么？

- A. 何时可以执行行动
- B. 执行行动后世界状态如何变化
- C. 世界的初始状态
- D. 要实现的目标条件

<details>
<summary>查看答案</summary>

**答案：B**

**解释**：后继状态公理描述执行行动后世界状态如何变化——它们指定行动的效果。

**详细说明**：

- 对于每个流元，我们指定：何时它变为真、假或保持不变
- 前提条件公理告诉我们"何时可以做"
- 后继状态公理告诉我们"做了之后会发生什么"
- 它们一起完整地描述了行动的可执行性和效果

</details>

---

### 第 13 题

**来源：情境演算 - 后继状态公理**

流元 R 的后继状态公理指出，行动 A 之后 R 为真，当且仅当：

- A. A 使 R 为真
- B. R 已经为真
- C. A 使 R 为真，或者（R 已经为真且 A 不使 R 为假）
- D. A 在当前情境中是可能的

<details>
<summary>查看答案</summary>

**答案：C**

**解释**：后继状态公理涵盖两种情况：(1) 行动使 R 为真（正效果），或 (2) R 已经为真且行动不使 R 为假（持久性）。

**详细说明**：
这个公式解决了框架问题：

- **情况 1**：行动的直接效果使 R 为真
- **情况 2**：R 持续存在，因为它为真且行动不使其为假
- 这避免了列出所有不变的东西（这会很庞大）

</details>

---

### 第 14 题

**来源：情境演算 - 后继状态公理**

在 `on(X,Y,S)` 的后继状态公理中，执行行动 A 后，`on(BlockA, BlockC, s')` 何时变为真？

- A. 仅当 A = move(BlockA, BlockB, BlockC)
- B. 仅当 on(BlockA, BlockC, s) 已经为真
- C. 如果 A = move(BlockA, BlockB, BlockC) 或者（on(BlockA, BlockC, s) 为真且 A ≠ move(BlockA, BlockC, \_)）
- D. 每当执行任何移动行动时

<details>
<summary>查看答案</summary>

**答案：C**

**解释**：`on(BlockA, BlockC, s')` 为真，如果：(1) 行动将 BlockA 移动到 BlockC，或 (2) BlockA 已经在 BlockC 上且行动没有将其移走。

**详细说明**：

- **正效果**：`A = move(BlockA, BlockB, BlockC)` 使其为真
- **持久性**：`on(BlockA, BlockC, s) ∧ ¬(A = move(BlockA, BlockC, _))` 保持其为真
- 其他行动不影响 `on` 关系

</details>

---

### 第 15 题

**来源：情境演算 - 领域公理化**

"公理化一个领域"是什么意思？

- A. 证明关于领域的数学定理
- B. 写下定义领域中真实内容的陈述
- C. 创建所有可能状态的数据库
- D. 优化领域性能

<details>
<summary>查看答案</summary>

**答案：B**

**解释**：公理化领域意味着写下定义领域中真实内容的逻辑陈述（公理）——为 AI 系统创建"规则手册"。

**详细说明**：
领域是特定的知识领域（例如，积木世界、出租车世界、厨房世界）

- 公理使计算机能够理解领域规则和关系
- 它们支持推理（推导新事实）和规划（达到目标状态）
- 必须完整、准确和简洁

</details>

---

### 第 16 题

**来源：情境演算 - 领域公理化步骤**

按顺序公理化领域的正确步骤是什么？

- A. 行动 → 流元 → 前提条件 → 初始状态 → 后继状态
- B. 理解领域 → 流元 → 行动 → 前提条件 → 后继状态 → 初始状态
- C. 初始状态 → 行动 → 流元 → 前提条件 → 后继状态
- D. 前提条件 → 后继状态 → 行动 → 流元 → 初始状态

<details>
<summary>查看答案</summary>

**答案：B**

**解释**：正确的顺序是：

1. 理解领域
2. 确定流元（状态描述）
3. 确定行动（变化机制）
4. 确定前提条件公理（执行条件）
5. 确定后继状态公理（变化法则）
6. 确定初始状态（起点）

**详细说明**：

- 从理解你正在建模的内容开始
- 识别需要跟踪的内容（流元）
- 识别可以改变事物的内容（行动）
- 定义何时可以发生变化（前提条件）
- 定义发生什么变化（后继状态）
- 定义起点（初始状态）

</details>

---

### 第 17 题

**来源：规划 - 简介**

人工智能中的规划是什么？

- A. 编写代码以实现系统
- B. 找到从初始状态实现目标状态的行动序列
- C. 组织项目任务和截止日期
- D. 调试程序中的错误

<details>
<summary>查看答案</summary>

**答案：B**

**解释**：规划是找到将初始状态转换为所需目标状态的行动序列的问题。

**详细说明**：

- 就像在地图上规划路线或决定完成任务的步骤
- 规划系统可以自动找到行动序列
- 例子：机器人规划对象移动、自动驾驶汽车规划路线、游戏 AI 规划策略

</details>

---

### 第 18 题

**来源：规划 - 积木世界**

在积木世界规划问题中，`clear(X, S)` 是什么意思？

- A. 积木 X 是透明的
- B. 积木 X 已从世界中移除
- C. 位置 X 在情境 S 中上面没有东西
- D. 积木 X 准备被删除

<details>
<summary>查看答案</summary>

**答案：C**

**解释**：`clear(X, S)` 是一个流元，意思是位置 X（可以是积木或位置）在情境 S 中上面没有东西。

**详细说明**：

- 清空的积木可以被移动
- 清空的位置可以放置东西
- "Clear"对于确定规划中的有效移动至关重要

</details>

---

### 第 19 题

**来源：规划 - Prolog 实现**

为什么查询 `?- clear(location(3), S).` 可能在深度优先规划中导致堆栈溢出？

- A. 查询语法不正确
- B. 位置 3 不存在
- C. 深度优先搜索可能探索无限的行动序列
- D. 世界中的积木太多

<details>
<summary>查看答案</summary>

**答案：C**

**解释**：深度优先搜索可能陷入探索无限长的计划（如反复来回移动积木）而找不到解决方案，最终耗尽堆栈空间。

**详细说明**：

- 深度优先在回溯之前尽可能深入探索一条路径
- 行动可以互相撤销，创建循环（将 b 移动到位置 2，将 b 移回 3，重复...）
- 没有循环检测，它会继续深入，直到发生堆栈溢出

</details>

---

### 第 20 题

**来源：规划 - 搜索策略**

在规划中，广度优先搜索相对于深度优先搜索的主要优势是什么？

- A. 广度优先使用更少的内存
- B. 广度优先运行更快
- C. 广度优先通过在增加长度之前探索给定长度的所有计划来避免无限下降
- D. 广度优先找到更长的计划

<details>
<summary>查看答案</summary>

**答案：C**

**解释**：广度优先搜索在尝试长度 N+1 之前探索长度 N 的所有计划，避免陷入无限长分支的问题。

**详细说明**：

- 逐层探索，就像波纹扩散
- 保证找到最短的解决方案
- 完整性：如果存在有限长度的解决方案，广度优先将找到它
- 权衡：需要更多内存来存储当前长度的所有计划

</details>

---

### 第 21 题

**来源：规划 - 广度优先策略**

在广度优先规划中，计划以什么顺序探索？

- A. 最长的计划优先，然后是较短的计划
- B. 随机顺序
- C. 所有长度为 1 的计划，然后所有长度为 2 的计划，然后长度为 3，等等
- D. 基于启发式首先探索最有希望的计划

<details>
<summary>查看答案</summary>

**答案：C**

**解释**：广度优先规划系统地探索递增长度的所有计划：首先所有 1 个行动的计划，然后所有 2 个行动的计划，依此类推。

**详细说明**：

- 级别 0：初始情境（没有行动）
- 级别 1：所有单行动计划
- 级别 2：所有 2 个行动的计划
- 级别 N：所有 N 个行动的计划
- 当计划满足目标时停止

</details>

---

### 第 22 题

**来源：规划 - Prolog 实现**

以下 Prolog 代码实现了什么？

```prolog
tryposs(S, S) :- poss(S).
tryposs(X, S) :- tryposs([_|X], S).
```

- A. 深度优先搜索
- B. 广度优先搜索
- C. 随机搜索
- D. 二分搜索

<details>
<summary>查看答案</summary>

**答案：B**

**解释**：这段代码通过回溯系统地尝试递增长度的计划来实现广度优先搜索。

**详细说明**：

- 基础情况：`tryposs(S, S)` 检查 S 是否是有效计划
- 递归情况：`tryposs([_|X], S)` 尝试多一个行动
- 通过回溯，尝试：`[]`、`[_]`、`[_,_]`、`[_,_,_]` 等
- 这在尝试长度 N+1 之前探索长度 N 的所有计划

</details>

---

### 第 23 题

**来源：规划 - 深度优先 vs 广度优先**

为什么深度优先规划可能陷入循环？

- A. 因为 Prolog 有错误
- B. 因为行动可以互相撤销，创建无限循环
- C. 因为初始状态不正确
- D. 因为目标无法到达

<details>
<summary>查看答案</summary>

**答案：B**

**解释**：行动通常可以撤销其他行动（例如，将 b 移动到位置 2，然后将其移回位置 3），创建深度优先搜索可以永远探索的循环。

**详细说明**：
没有循环检测：

- 深度优先持续探索更长的路径
- 可能以不同顺序重复访问相同状态
- 创建无限长的计划而找不到解决方案
- 最终导致堆栈溢出

</details>

---

### 第 24 题

**来源：规划 - 完整性**

搜索策略"完整"是什么意思？

- A. 它找到所有可能的解决方案
- B. 它无错误运行
- C. 如果存在有限长度的解决方案，该策略将找到它
- D. 它快速找到解决方案

<details>
<summary>查看答案</summary>

**答案：C**

**解释**：完整的搜索策略保证，如果存在有限长度的解决方案，该策略最终将找到它。

**详细说明**：

- 广度优先搜索对于规划问题是完整的
- 深度优先搜索不完整（可能陷入无限分支）
- 完整性不保证效率，只保证最终成功

</details>

---

### 第 25 题

**来源：规划 - 最优性**

如果广度优先规划找到了解决方案，我们可以说什么？

- A. 这是执行最快的计划
- B. 这是唯一可能的计划
- C. 它保证是最短的可能计划之一
- D. 它使用最少的内存

<details>
<summary>查看答案</summary>

**答案：C**

**解释**：广度优先搜索按长度递增的顺序探索计划，因此找到的第一个解决方案保证是最短的。

**详细说明**：

- 在任何 2 个行动的计划之前探索所有 1 个行动的计划
- 在任何 3 个行动的计划之前探索所有 2 个行动的计划
- 因此，找到的第一个解决方案具有最小长度
- 这被称为相对于计划长度"最优"

</details>

---

### 第 26 题

**来源：情境演算 - Prolog 约定**

在 Prolog 情境演算实现中，为什么我们将情境表示为列表？

- A. 因为 Prolog 只支持列表
- B. 为了效率并使用 Prolog 的内置列表操作
- C. 因为教科书要求它
- D. 使调试更容易

<details>
<summary>查看答案</summary>

**答案：B**

**解释**：使用列表使表示更简洁、可读，并允许使用丰富的 Prolog 列表操作，如 append、member 等。

**详细说明**：
转换规则：

- 初始情境 S → 空列表 `[]`
- `do(a,s)` → `[a|s]`（列表构造器）
- 嵌套的 `do` 函数变成线性列表
- 更符合 Prolog 习惯的风格

</details>

---

### 第 27 题

**来源：情境演算 - Prolog 实现**

`poss([move(Block,From,To)|S])` 检查什么？

- A. 移动行动是否已执行
- B. 移动行动在情境 S 中是否可能
- C. 积木是否存在
- D. 情境是否有效

<details>
<summary>查看答案</summary>

**答案：B**

**解释**：`poss([move(Block,From,To)|S])` 检查移动行动在情境 S 中是否满足所有前提条件。

**详细说明**：
前提条件公理检查：

- 积木存在且清空
- 目标存在且清空
- 积木不移动到它自己上面
- 积木实际上在源位置

</details>

---

### 第 28 题

**来源：规划 - 后继状态公理**

在 `clear(X,S)` 的后继状态公理中，规则 `clear(X,[move(Z,X,Y)|S]) :- poss([move(Z,X,Y)|S])` 是什么意思？

- A. 如果我们将某物移动到 X，X 变为清空
- B. 如果我们将某物从 X 移开，X 变为清空
- C. 任何移动后 X 保持清空
- D. X 永远不会清空

<details>
<summary>查看答案</summary>

**答案：B**

**解释**：此规则指出，当我们将积木 Z 从 X 移到 Y 时，位置 X 变为清空，因为从 X 移除某物使其清空。

**详细说明**：

- `move(Z,X,Y)` 表示将积木 Z 从位置 X 移动到位置 Y
- 此移动后，X 上没有任何东西了
- 因此 X 是清空的
- 这是 clear 流元的"正效果"规则

</details>

---

### 第 29 题

**来源：规划 - 持久性**

后继状态公理中的"持久性"规则是什么？

- A. 计划必须保存到磁盘
- B. 为真的流元保持为真，除非行动使其为假
- C. 行动一旦执行就永远持续
- D. 系统永远不会忘记初始状态

<details>
<summary>查看答案</summary>

**答案：B**

**解释**：持久性规则指出，为真的事物保持为真，除非行动特别改变它们——解决框架问题。

**详细说明**：
`on(X,Y,S)` 的例子：

```prolog
on(X,Y,[A|S]) :- poss([A|S]), A \= move(X,Y,_), on(X,Y,S).
```

- 如果 X 之前在 Y 上，X 保持在 Y 上
- 并且行动不将 X 从 Y 移开
- 这避免了列出每个不影响 on(X,Y) 的行动

</details>

---

### 第 30 题

**来源：规划 - 框架问题**

后继状态公理帮助解决的框架问题是什么？

- A. 如何在对象周围绘制框
- B. 如何在不列出所有内容的情况下指定行动后什么改变和什么保持不变
- C. 如何创建高效的数据结构
- D. 如何优化 Prolog 查询

<details>
<summary>查看答案</summary>

**答案：B**

**解释**：框架问题是关于如何有效地指定行动后什么改变和什么持续，而不必显式列出每个不变的事实。

**详细说明**：

- 在复杂世界中，行动发生时大多数事物不会改变
- 列出所有不变的事物将是不切实际的
- 后继状态公理通过以下方式解决这个问题：
  - 显式说明什么使流元为真/假
  - 使用持久性规则："保持为真，除非变为假"
- 这种紧凑的表示是可管理和完整的

</details>

---

## 📝 第二部分：填空题

**说明**：每题 1 分，共 10 分。用最合适的答案填空。

### 第 31 题

**来源：情境演算 - 基本元素**

情境演算的三个基本元素是****\_\_****、流元和情境。

<details>
<summary>查看答案</summary>

**答案**：行动

**解释**：三个基本元素是行动（改变世界的操作）、流元（描述世界状态的谓词）和情境（行动历史）。

</details>

---

### 第 32 题

**来源：情境演算 - 流元**

流元是接受****\_\_****参数并表示因行动而改变真值的陈述的谓词。

<details>
<summary>查看答案</summary>

**答案**：情境

**解释**：所有流元必须包含情境参数作为它们的最后一个参数，因为它们的真值取决于我们在哪个情境（行动历史）中。

</details>

---

### 第 33 题

**来源：情境演算 - 情境**

在现代情境演算中，情境表示****\_\_**** ****\_\_****，而不是状态。

<details>
<summary>查看答案</summary>

**答案**：行动历史

**解释**：现代情境演算的一个关键区别是情境表示行动历史（行动序列）而不是状态（世界的描述）。

</details>

---

### 第 34 题

**来源：情境演算 - 初始情境**

特殊符号****\_\_****（或 Prolog 中的 `[]`）表示尚未发生任何行动的初始情境。

<details>
<summary>查看答案</summary>

**答案**：S₀ 或 S（接受任一）

**解释**：S₀（S-零或只是 S）表示初始情境。在 Prolog 实现中，我们使用空列表 `[]` 以便于操作。

</details>

---

### 第 35 题

**来源：情境演算 - 公理**

通过写下定义领域中真实内容的****\_\_****来形式化领域。

<details>
<summary>查看答案</summary>

**答案**：公理

**解释**：公理是定义领域中真实内容的基础陈述和规则——该世界的"规则手册"。

</details>

---

### 第 36 题

**来源：情境演算 - 前提条件公理**

****\_\_****公理指定每个行动在什么条件下是可能的。

<details>
<summary>查看答案</summary>

**答案**：前提条件 或 行动前提条件（接受任一）

**解释**：前提条件公理（或行动前提条件公理）通过列出必须满足的条件来指定何时可以执行行动。

</details>

---

### 第 37 题

**来源：情境演算 - 后继状态公理**

****\_\_**** ****\_\_****公理指定行动发生后什么为真。

<details>
<summary>查看答案</summary>

**答案**：后继状态

**解释**：后继状态公理描述执行行动后世界状态如何变化——指定行动的效果。

</details>

---

### 第 38 题

**来源：规划 - 搜索策略**

****\_\_****优先搜索通过在增加长度之前探索给定长度的所有计划来避免无限下降。

<details>
<summary>查看答案</summary>

**答案**：广度

**解释**：广度优先搜索系统地逐层探索，在任何长度 N+1 的计划之前检查所有长度 N 的计划。

</details>

---

### 第 39 题

**来源：规划 - 深度优先问题**

深度优先规划可能不会终止，因为行动可以互相撤销，创建****\_\_****。

<details>
<summary>查看答案</summary>

**答案**：循环 或 无限循环（接受任一）

**解释**：当行动可以撤销彼此的效果时，深度优先搜索可能陷入以不同顺序重复探索相同状态，创建无限循环。

</details>

---

### 第 40 题

**来源：规划 - 最优性**

广度优先搜索保证找到****\_\_****可能的计划。

<details>
<summary>查看答案</summary>

**答案**：最短 或 最优（接受任一）

**解释**：因为广度优先按长度递增的顺序探索计划，所以找到的第一个解决方案保证是最短的（相对于长度最优）。

</details>

---

## 📝 第三部分：简答题

**说明**：用 2-4 句话回答。共 15 分。

### 第 41 题（3 分）

**来源：情境演算 - 情境 vs 状态**

解释情境演算中"情境"和"状态"之间的关键区别。为什么这种区别很重要？

<details>
<summary>查看答案</summary>

**答案**：

情境表示行动历史（已执行的行动序列），而状态描述世界在特定时间点的样子。这种区别很重要，因为相同的状态可以通过不同的行动序列到达，但每个序列是唯一的。从行动历史我们可以推导当前状态，但仅从状态无法确定我们如何到达那里，这对于推理行动和变化至关重要。

**关键要点**：

- 情境 = 行动历史（我们如何到达这里）
- 状态 = 世界配置（现在什么为真）
- 行动序列的唯一性
- 实现可追溯性和推理

</details>

---

### 第 42 题（3 分）

**来源：情境演算 - 前提条件公理**

用通俗的英语，当为领域写下前提条件公理时，正在指定什么？提供积木世界的一个例子。

<details>
<summary>查看答案</summary>

**答案**：

前提条件公理指定"在什么条件下可以执行行动"——就像定义操作何时有效的游戏规则。它们描述在可以执行行动之前世界必须是什么样子。例如，在积木世界中，要将积木 A 从位置 B 移动到位置 C，前提条件可能包括：积木 A 必须存在，积木 A 必须是清空的（上面没有东西），位置 C 必须是清空的，积木 A 必须实际在位置 B。

**关键要点**：

- 定义行动的执行条件
- 防止不可能/无效的行动
- 例子包括多个现实的前提条件
- 使用领域特定的上下文（积木世界）

</details>

---

### 第 43 题（3 分）

**来源：情境演算 - 后继状态公理**

用通俗的英语，当为领域写下后继状态公理时，正在指定什么？为什么我们需要正效果和负效果？

<details>
<summary>查看答案</summary>

**答案**：

后继状态公理指定"执行行动后世界状态如何变化"——描述行动的效果。我们需要指定流元何时变为真（正效果）和何时变为假（负效果），以准确预测行动后的世界。我们还需要指定持久性（事物何时保持不变），这通过避免需要列出所有不变的事物来解决框架问题。

**关键要点**：

- 描述行动效果/后果
- 正效果（什么变为真）
- 负效果（什么变为假）
- 持久性（什么保持不变）
- 解决框架问题

</details>

---

### 第 44 题（3 分）

**来源：规划 - 深度优先 vs 广度优先**

为什么深度优先规划有时即使存在解决方案也找不到？广度优先搜索如何解决这个问题？

<details>
<summary>查看答案</summary>

**答案**：

深度优先规划可能陷入无限分支，因为行动可以互相撤销，创建循环（例如，反复来回移动积木）。深度优先搜索尽可能深入地探索一条路径，因此如果它进入无限分支，它永远不会回溯尝试其他选项，最终导致堆栈溢出。广度优先搜索通过在尝试长度 N+1 之前探索长度 N 的所有计划来解决这个问题，确保系统地探索所有可能性，并保证如果存在有限的解决方案，就会找到它。

**关键要点**：

- 深度优先可以进入无限分支
- 创建循环的行动
- 广度优先逐层探索
- 完整性保证

</details>

---

### 第 45 题（3 分）

**来源：情境演算 - 领域公理化**

按顺序列出公理化领域的六个步骤。简要解释为什么这个顺序有意义。

<details>
<summary>查看答案</summary>

**答案**：

六个步骤是：(1) 理解领域，(2) 确定流元，(3) 确定行动，(4) 确定前提条件公理，(5) 确定后继状态公理，(6) 确定初始状态。这个顺序有意义，因为我们必须首先理解我们正在建模什么，然后才能识别需要跟踪的内容（流元）、可以引起变化的内容（行动）、何时可以发生变化（前提条件）、发生什么变化（后继状态），最后从哪里开始（初始状态）。每个步骤都建立在前一个步骤的基础上。

**关键要点**：

- 按正确顺序列出所有六个步骤
- 逻辑进展解释
- 每个步骤建立在前一个步骤上
- 展示对依赖关系的理解

</details>

---

## 📝 第四部分：Prolog 编程题

**说明**：编写 Prolog 代码。共 5 分。

### 第 46 题（5 分）

**来源：情境演算与规划 - 实现**

考虑一个简化的机器人世界，具有以下元素：

- 机器人可以在不同位置：`location(1)`、`location(2)`、`location(3)`
- 机器人一次可以携带一个物品
- 行动：`goto(From, To)` 和 `pickup(Item)`

编写以下 Prolog 谓词：

a) `goto(From, To)` 的前提条件公理，要求：

- 机器人必须在位置 From
- From 和 To 必须是不同的位置

b) 流元 `at(Robot, Loc, S)` 的后继状态公理，当机器人移动到该位置时变为真

<details>
<summary>查看答案</summary>

**答案**：

```prolog
% a) goto 行动的前提条件公理
poss([goto(From, To)|S]) :-
    location_exists(From),
    location_exists(To),
    From \= To,
    at(robot, From, S).

% b) at(Robot, Loc, S) 的后继状态公理
% 情况 1：如果我们刚移动到那里，机器人在 Loc
at(robot, Loc, [goto(From, Loc)|S]) :-
    poss([goto(From, Loc)|S]).

% 情况 2：如果机器人在那里并且没有移开，机器人保持在 Loc
at(robot, Loc, [A|S]) :-
    poss([A|S]),
    A \= goto(Loc, _),
    at(robot, Loc, S).

% 辅助事实（示例）
location_exists(location(1)).
location_exists(location(2)).
location_exists(location(3)).
```

**评分标准**（总共 5 分）：

- 前提条件公理结构正确（1 分）
- 检查所有必需的前提条件（1 分）
- 后继状态公理"变为真"情况（1.5 分）
- 后继状态公理"持久性"情况（1.5 分）

**关键要素**：

- 正确使用 `poss/1` 谓词
- 使用列表的正确情境表示法
- 正确使用 `\=` 表示不等式
- 后继状态公理中的正效果和持久性情况

</details>

---

## 🎓 考试结束

**评分摘要**：

- 选择题：**\_** / 30 分
- 填空题：**\_** / 10 分
- 简答题：**\_** / 15 分
- Prolog 编程题：**\_** / 5 分
- **总分：**\_** / 60 分**

**评分标准**：

- A: 54-60 分（90-100%）
- B: 48-53 分（80-89%）
- C: 42-47 分（70-79%）
- D: 36-41 分（60-69%）
- F: 36 分以下（60% 以下）

---

**考试版本**：1.0
**创建日期**：2024 年 11 月
**涵盖主题**：情境演算、规划、广度优先搜索、Prolog 实现
