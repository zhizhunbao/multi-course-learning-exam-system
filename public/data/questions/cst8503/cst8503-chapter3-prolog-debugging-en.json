{
  "courseId": "cst8503",
  "chapterId": "chapter3-prolog-debugging",
  "title": "Prolog调试",
  "description": "Prolog调试相关题目",
  "totalQuestions": 6,
  "lastUpdated": "2025-10-16",
  "language": "en",
  "questions": [
    {
      "id": 14,
      "type": "multiple-choice",
      "question": "What is the purpose of the trace/0 predicate in Prolog debugging?",
      "options": [
        "Stop execution",
        "Step-by-step tracing",
        "Set breakpoints",
        "View variables"
      ],
      "correctAnswer": 1,
      "explanation": "The trace/0 predicate steps through subsequent goals, showing execution information.",
      "difficulty": "medium",
      "tags": ["chapter3-prolog-debugging"],
      "points": 1
    },
    {
      "id": 22,
      "type": "multiple-choice",
      "question": "What is the correct definition of the member/2 predicate in Prolog?",
      "options": [
        "member(X,[X|_]).",
        "member(X,[_|L]) :- member(X,L).",
        "Both of the above",
        "None of the above"
      ],
      "correctAnswer": 2,
      "explanation": "The member/2 predicate needs two clauses: one base case (X as head) and one recursive case (X in tail).",
      "difficulty": "medium",
      "tags": ["chapter3-prolog-debugging"],
      "points": 1
    },
    {
      "id": 23,
      "type": "multiple-choice",
      "question": "What is the purpose of the conc/3 predicate in Prolog?",
      "options": [
        "Delete elements",
        "Concatenate lists",
        "Find elements",
        "Sort lists"
      ],
      "correctAnswer": 1,
      "explanation": "The conc/3 predicate is used to concatenate two lists, conc(L1,L2,L3) means L3 is the concatenation of L1 and L2.",
      "difficulty": "medium",
      "tags": ["chapter3-prolog-debugging"],
      "points": 1
    },
    {
      "id": 42,
      "type": "multiple-choice",
      "question": "What is the purpose of the spy/1 predicate in Prolog?",
      "options": [
        "Stop tracing",
        "Set breakpoints",
        "Specify predicate to be traced",
        "View variable values"
      ],
      "correctAnswer": 2,
      "explanation": "The spy/1 predicate specifies a predicate (e.g., parent) to be traced, e.g., spy(parent).",
      "difficulty": "medium",
      "tags": ["chapter3-prolog-debugging"],
      "points": 1
    },
    {
      "id": 34,
      "type": "coding",
      "question": "Write a complete Prolog program that implements the ancestor/2 predicate with proper debugging features. Include facts for a family tree, the ancestor rules, and demonstrate how to use trace/0 and spy/1 for debugging the ancestor relationship.",
      "correctAnswer": "% Family tree facts\nparent(john, mary).\nparent(mary, tom).\nparent(tom, lisa).\nparent(john, sarah).\nparent(sarah, lisa).\n\n% Ancestor predicate\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).\n\n% Debugging example:\n% ?- trace.\n% ?- ancestor(john, lisa).\n% ?- nospy.\n% ?- spy(ancestor).\n% ?- ancestor(john, tom).\n\n% Alternative debugging with guitracer:\n% ?- guitracer.\n% ?- ancestor(john, lisa).",
      "explanation": "This demonstrates proper Prolog debugging techniques including trace/0 for step-by-step execution, spy/1 for predicate-specific tracing, and guitracer/0 for graphical debugging.",
      "difficulty": "medium",
      "tags": ["chapter3-prolog-debugging"],
      "points": 2
    },
    {
      "id": 36,
      "type": "coding",
      "question": "Write a complete Prolog program that implements the length/2 predicate with debugging capabilities. Include test cases and demonstrate how to debug recursive predicates using trace/0, showing the step-by-step execution of length([1,2,3], N).",
      "correctAnswer": "% Length predicate\nlength([], 0).\nlength([_ | L], N) :- length(L, N0), N is N0 + 1.\n\n% Test cases\n% ?- length([], N).\n% ?- length([1], N).\n% ?- length([1,2,3], N).\n\n% Debugging example:\n% ?- trace.\n% ?- length([1,2,3], N).\n% This will show:\n% 1. Call: length([1,2,3], _G123)\n% 2. Call: length([2,3], _G124)\n% 3. Call: length([3], _G125)\n% 4. Call: length([], _G126)\n% 5. Exit: length([], 0)\n% 6. Exit: length([3], 1)\n% 7. Exit: length([2,3], 2)\n% 8. Exit: length([1,2,3], 3)\n\n% Alternative with spy:\n% ?- spy(length).\n% ?- length([1,2,3], N).",
      "explanation": "This demonstrates debugging recursive predicates, showing how trace/0 reveals the step-by-step execution and variable bindings in recursive calls.",
      "difficulty": "medium",
      "tags": ["chapter3-prolog-debugging"],
      "points": 2
    }
  ]
}
