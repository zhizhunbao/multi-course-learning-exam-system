{
  "courseId": "cst8503",
  "chapterId": 4,
  "title": "Chapter 4: Prolog Structures and Matching",
  "description": "Learning about Prolog structures, pattern matching, unification, and how to work with complex data structures in Prolog",
  "duration": "3 hours",
  "difficulty": "Intermediate",
  "lastUpdated": "2025-01-16",
  "learningObjectives": [
    "Understand Prolog structures and their syntax",
    "Master pattern matching and unification",
    "Learn to work with complex data structures",
    "Understand the difference between structures and lists",
    "Practice building and manipulating structures"
  ],
  "lessons": [
    {
      "id": 1,
      "title": "4.1 Introduction to Structures",
      "type": "theory",
      "duration": "35 minutes",
      "order": 1,
      "content": {
        "overview": "Introduction to Prolog structures and their role in representing complex data",
        "sections": [
          {
            "title": "What are Structures?",
            "content": "Structures are compound terms that group related data together. They consist of a functor and arguments.",
            "keyPoints": [
              "Structures are compound terms",
              "Consist of functor and arguments",
              "Represent complex data",
              "Examples: person(john, 25), point(3, 4)"
            ]
          },
          {
            "title": "Structure Syntax",
            "content": "Structures follow the syntax: functor(argument1, argument2, ...). The functor is an atom, arguments can be any terms.",
            "keyPoints": [
              "Syntax: functor(arg1, arg2, ...)",
              "Functor is an atom",
              "Arguments can be any terms",
              "Arity is the number of arguments"
            ]
          },
          {
            "title": "Structure Examples",
            "content": "Common examples of structures in Prolog programming.",
            "codeExample": {
              "language": "prolog",
              "code": "% Person structure\nperson(Name, Age, City).\n\n% Point structure\npoint(X, Y).\n\n% Date structure\ndate(Year, Month, Day).\n\n% Facts using structures\nperson(john, 25, toronto).\npoint(3, 4).\ndate(2025, 1, 16).",
              "explanation": "These examples show how structures can represent different types of complex data with multiple attributes."
            }
          }
        ]
      },
      "resources": [
        {
          "name": "Structure Syntax Reference",
          "type": "reference",
          "url": "#",
          "description": "Complete reference for Prolog structure syntax"
        }
      ],
      "exercises": [
        {
          "type": "multiple_choice",
          "question": "What is the functor of the structure person(john, 25, toronto)?",
          "options": ["john", "person", "25", "toronto"],
          "correct": 1,
          "explanation": "The functor is 'person', which is the name of the structure. The arguments are john, 25, and toronto."
        }
      ]
    },
    {
      "id": 2,
      "title": "4.2 Pattern Matching and Unification",
      "type": "theory",
      "duration": "40 minutes",
      "order": 2,
      "content": {
        "overview": "Understanding how Prolog matches structures and performs unification",
        "sections": [
          {
            "title": "Unification Process",
            "content": "Unification is the process of making two terms identical by binding variables. It's fundamental to Prolog's operation.",
            "keyPoints": [
              "Unification makes terms identical",
              "Variables are bound during unification",
              "Fails if terms cannot be unified",
              "Succeeds if terms match or can be made to match"
            ]
          },
          {
            "title": "Structure Matching",
            "content": "Structures match if they have the same functor, same arity, and all corresponding arguments can be unified.",
            "keyPoints": [
              "Same functor required",
              "Same arity required",
              "Corresponding arguments must unify",
              "Variables can be bound to match"
            ]
          },
          {
            "title": "Unification Examples",
            "content": "Examples of successful and failed unification with structures.",
            "codeExample": {
              "language": "prolog",
              "code": "% Successful unifications\nperson(X, 25, toronto) = person(john, Y, Z).\n% X = john, Y = 25, Z = toronto\n\npoint(A, B) = point(3, 4).\n% A = 3, B = 4\n\n% Failed unifications\nperson(john, 25) = person(john, 25, toronto).\n% Different arity - fails\n\nperson(john, 25) = point(3, 4).\n% Different functors - fails",
              "explanation": "Successful unification binds variables to make structures identical. Failed unification occurs when structures cannot be made identical."
            }
          }
        ]
      },
      "resources": [
        {
          "name": "Unification Visualizer",
          "type": "tool",
          "url": "#",
          "description": "Interactive tool to visualize unification process"
        }
      ],
      "exercises": [
        {
          "type": "multiple_choice",
          "question": "Which unification will succeed?",
          "options": [
            "person(X, 25) = person(john, 25, toronto)",
            "person(john, Y) = person(john, 25)",
            "point(3, 4) = person(john, 25)",
            "date(2025, 1) = date(2025, 1, 16)"
          ],
          "correct": 1,
          "explanation": "person(john, Y) = person(john, 25) succeeds because both have the same functor 'person', same arity 2, and Y can be bound to 25."
        }
      ]
    },
    {
      "id": 3,
      "title": "4.3 Working with Structure Arguments",
      "type": "practice",
      "duration": "45 minutes",
      "order": 3,
      "content": {
        "overview": "Learning to access and manipulate individual arguments of structures",
        "sections": [
          {
            "title": "Accessing Structure Arguments",
            "content": "You can access individual arguments of structures by pattern matching in rule heads and query goals.",
            "keyPoints": [
              "Pattern matching in rule heads",
              "Variable binding in queries",
              "Selective argument access",
              "Multiple argument extraction"
            ]
          },
          {
            "title": "Rules with Structures",
            "content": "Writing rules that work with structures by pattern matching on their arguments.",
            "codeExample": {
              "language": "prolog",
              "code": "% Facts with structures\nperson(john, 25, toronto).\nperson(mary, 30, vancouver).\nperson(tom, 22, toronto).\n\n% Rules accessing structure arguments\nadult(Name) :- person(Name, Age, _), Age >= 18.\ntoronto_resident(Name) :- person(Name, _, toronto).\n\n% Rules creating new structures\nolder_person(Person1, Person2) :-\n    person(Name1, Age1, _),\n    person(Name2, Age2, _),\n    Age1 > Age2,\n    Person1 = person(Name1, Age1),\n    Person2 = person(Name2, Age2).",
              "explanation": "These rules demonstrate how to access structure arguments using pattern matching and create new structures."
            }
          }
        ]
      },
      "resources": [
        {
          "name": "Structure Manipulation Exercises",
          "type": "exercise",
          "url": "#",
          "description": "Practice exercises for working with structure arguments"
        }
      ],
      "exercises": [
        {
          "type": "coding",
          "question": "Write a rule that finds all people who live in the same city as a given person.",
          "hint": "Use pattern matching to extract the city from the given person and match it with others",
          "solution": "same_city(Person1, Person2) :-\n    person(Name1, _, City),\n    person(Name2, _, City),\n    Person1 = person(Name1, _, City),\n    Person2 = person(Name2, _, City),\n    Name1 \\= Name2.",
          "explanation": "The rule extracts the city from Person1, finds another person in the same city, and creates structures for both people."
        }
      ]
    },
    {
      "id": 4,
      "title": "4.4 Nested Structures",
      "type": "practice",
      "duration": "40 minutes",
      "order": 4,
      "content": {
        "overview": "Working with nested structures and complex data representations",
        "sections": [
          {
            "title": "Nested Structure Examples",
            "content": "Structures can contain other structures as arguments, creating nested data representations.",
            "keyPoints": [
              "Structures can contain other structures",
              "Enables complex data modeling",
              "Requires careful pattern matching",
              "Examples: person(name(first, last), age, address(street, city))"
            ]
          },
          {
            "title": "Working with Nested Structures",
            "content": "Pattern matching and accessing data in nested structures requires understanding the nesting levels.",
            "codeExample": {
              "language": "prolog",
              "code": "% Nested structure facts\nperson(name(john, smith), 25, address(main_st, toronto)).\nperson(name(mary, jones), 30, address(oak_ave, vancouver)).\n\n% Rules working with nested structures\nfirst_name(person(name(First, _), _, _), First).\nlast_name(person(name(_, Last), _, _), Last).\ncity(person(_, _, address(_, City)), City).\n\n% Complex query\nfind_person_by_city(City, Person) :-\n    person(Name, Age, address(_, City)),\n    Person = person(Name, Age, address(_, City)).",
              "explanation": "These examples show how to work with nested structures by pattern matching at different levels of nesting."
            }
          }
        ]
      },
      "resources": [
        {
          "name": "Nested Structure Tutorial",
          "type": "tutorial",
          "url": "#",
          "description": "Step-by-step tutorial on working with nested structures"
        }
      ],
      "exercises": [
        {
          "type": "coding",
          "question": "Write a rule that finds all people with the same last name.",
          "hint": "Use pattern matching to extract last names from nested name structures",
          "solution": "same_last_name(Person1, Person2) :-\n    person(name(_, Last1), _, _),\n    person(name(_, Last2), _, _),\n    Last1 = Last2,\n    Person1 = person(name(_, Last1), _, _),\n    Person2 = person(name(_, Last2), _, _),\n    Person1 \\= Person2.",
          "explanation": "The rule extracts last names from nested name structures, finds people with matching last names, and creates structures for them."
        }
      ]
    },
    {
      "id": 5,
      "title": "4.5 Structures vs Lists",
      "type": "theory",
      "duration": "30 minutes",
      "order": 5,
      "content": {
        "overview": "Understanding when to use structures versus lists in Prolog",
        "sections": [
          {
            "title": "When to Use Structures",
            "content": "Structures are ideal when you have a fixed number of related components with specific meanings.",
            "keyPoints": [
              "Fixed number of components",
              "Components have specific meanings",
              "Type safety through functor",
              "Examples: coordinates, dates, records"
            ]
          },
          {
            "title": "When to Use Lists",
            "content": "Lists are better for variable-length sequences of similar items.",
            "keyPoints": [
              "Variable number of items",
              "Items are similar in nature",
              "Order matters",
              "Examples: shopping lists, sequences"
            ]
          },
          {
            "title": "Comparison Examples",
            "content": "Examples showing when structures or lists are more appropriate.",
            "codeExample": {
              "language": "prolog",
              "code": "% Structure: fixed components with meaning\npoint(3, 4).\ndate(2025, 1, 16).\nperson(name(john, smith), 25, toronto).\n\n% List: variable length sequence\n[apple, banana, orange].\n[1, 2, 3, 4, 5].\n[person(john, 25), person(mary, 30), person(tom, 22)].",
              "explanation": "Structures are used for fixed-arity data with semantic meaning, while lists are used for variable-length sequences."
            }
          }
        ]
      },
      "resources": [
        {
          "name": "Structures vs Lists Guide",
          "type": "reference",
          "url": "#",
          "description": "Guide for choosing between structures and lists"
        }
      ],
      "exercises": [
        {
          "type": "multiple_choice",
          "question": "Which is more appropriate for representing a student's grade in a course?",
          "options": [
            "Structure: grade(student, course, score)",
            "List: [student, course, score]",
            "Both are equally appropriate",
            "Neither is appropriate"
          ],
          "correct": 0,
          "explanation": "A structure is more appropriate because a grade has a fixed number of components (student, course, score) with specific meanings."
        }
      ]
    }
  ],
  "assessment": {
    "quiz": {
      "questions": [
        {
          "id": 1,
          "type": "multiple_choice",
          "question": "What is the functor of the structure date(2025, 1, 16)?",
          "options": ["2025", "date", "1", "16"],
          "correct": 1,
          "points": 2
        },
        {
          "id": 2,
          "type": "multiple_choice",
          "question": "When does unification of two structures succeed?",
          "options": [
            "When they have the same functor",
            "When they have the same arity",
            "When all corresponding arguments can be unified",
            "All of the above"
          ],
          "correct": 3,
          "points": 2
        },
        {
          "id": 3,
          "type": "true_false",
          "question": "Structures are better than lists when you have a fixed number of components with specific meanings.",
          "correct": true,
          "points": 1
        },
        {
          "id": 4,
          "type": "multiple_choice",
          "question": "What happens when you try to unify person(john, 25) with person(john, 25, toronto)?",
          "options": [
            "Succeeds with X = toronto",
            "Fails due to different arity",
            "Succeeds with no variable binding",
            "Creates a new structure"
          ],
          "correct": 1,
          "points": 2
        }
      ],
      "totalPoints": 7,
      "passingScore": 4
    }
  },
  "resources": {
    "readings": [
      {
        "title": "Prolog Structures and Pattern Matching",
        "author": "Todd Kelley",
        "type": "course_notes",
        "url": "#",
        "description": "Comprehensive guide to Prolog structures and unification"
      }
    ],
    "videos": [
      {
        "title": "Working with Structures in Prolog",
        "duration": "30 minutes",
        "url": "#",
        "description": "Demonstration of structure manipulation and pattern matching"
      }
    ],
    "tools": [
      {
        "name": "Structure Practice Environment",
        "type": "programming",
        "url": "#",
        "description": "Online environment for practicing with structures"
      }
    ]
  },
  "prerequisites": [3],
  "nextChapter": 5
}
