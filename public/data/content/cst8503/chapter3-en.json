{
  "courseId": "cst8503",
  "chapterId": 3,
  "title": "Chapter 3: Prolog Debugging",
  "description": "Learning debugging techniques and tools in Prolog, including trace, spy, and common debugging strategies for logical programs",
  "duration": "2.5 hours",
  "difficulty": "Intermediate",
  "lastUpdated": "2025-01-16",
  "learningObjectives": [
    "Understand Prolog's execution model and backtracking",
    "Learn to use trace and spy for debugging",
    "Master common debugging techniques",
    "Understand how to debug recursive programs",
    "Practice debugging real Prolog programs"
  ],
  "lessons": [
    {
      "id": 1,
      "title": "3.1 Understanding Prolog Execution",
      "type": "theory",
      "duration": "30 minutes",
      "order": 1,
      "content": {
        "overview": "Understanding how Prolog executes queries and the role of backtracking",
        "sections": [
          {
            "title": "Execution Model",
            "content": "Prolog uses a depth-first search with backtracking to find solutions. Understanding this model is crucial for effective debugging.",
            "keyPoints": [
              "Depth-first search with backtracking",
              "Goals are resolved left-to-right",
              "Backtracking occurs when goals fail",
              "Variables are bound and unbound during execution"
            ]
          },
          {
            "title": "Backtracking Process",
            "content": "When a goal fails, Prolog backtracks to the most recent choice point and tries alternative solutions.",
            "keyPoints": [
              "Backtracking to choice points",
              "Trying alternative solutions",
              "Unbinding variables",
              "Continuing until success or failure"
            ]
          }
        ]
      },
      "resources": [
        {
          "name": "Prolog Execution Visualization",
          "type": "animation",
          "url": "#",
          "description": "Visual representation of Prolog execution and backtracking"
        }
      ],
      "exercises": [
        {
          "type": "multiple_choice",
          "question": "What happens when a Prolog goal fails?",
          "options": [
            "The program terminates",
            "Prolog backtracks to the most recent choice point",
            "All variables are unbound",
            "The query is re-executed"
          ],
          "correct": 1,
          "explanation": "When a goal fails, Prolog backtracks to the most recent choice point and tries alternative solutions."
        }
      ]
    },
    {
      "id": 2,
      "title": "3.2 Using Trace for Debugging",
      "type": "practice",
      "duration": "40 minutes",
      "order": 2,
      "content": {
        "overview": "Learning to use the trace facility to debug Prolog programs",
        "sections": [
          {
            "title": "Trace Command",
            "content": "The trace command shows the step-by-step execution of Prolog queries, including goal calls, successes, and failures.",
            "keyPoints": [
              "trace/0 starts tracing",
              "notrace/0 stops tracing",
              "Shows goal calls and exits",
              "Displays variable bindings"
            ]
          },
          {
            "title": "Trace Output Interpretation",
            "content": "Understanding trace output is essential for effective debugging.",
            "codeExample": {
              "language": "prolog",
              "code": "?- trace.\n?- parent(X, mary).\n   Call: (7) parent(_G123, mary) ? creep\n   Exit: (7) parent(john, mary) ? creep\nX = john ;\n   Redo: (7) parent(_G123, mary) ? creep\n   Exit: (7) parent(susan, mary) ? creep\nX = susan",
              "explanation": "Trace shows the call, exit, and redo steps of goal execution with variable bindings."
            }
          }
        ]
      },
      "resources": [
        {
          "name": "Trace Practice Environment",
          "type": "tool",
          "url": "#",
          "description": "Interactive environment for practicing trace debugging"
        }
      ],
      "exercises": [
        {
          "type": "coding",
          "question": "Use trace to debug why the query ?- ancestor(john, alice). fails. What does the trace output show?",
          "hint": "Enable trace, run the query, and observe the execution steps",
          "solution": "?- trace.\n?- ancestor(john, alice).\n% Trace will show the execution steps and where it fails",
          "explanation": "Trace will show the step-by-step execution, revealing where the ancestor rule fails to find a solution."
        }
      ]
    },
    {
      "id": 3,
      "title": "3.3 Using Spy Points",
      "type": "practice",
      "duration": "35 minutes",
      "order": 3,
      "content": {
        "overview": "Learning to use spy points for selective debugging of specific predicates",
        "sections": [
          {
            "title": "Spy Points",
            "content": "Spy points allow you to set breakpoints on specific predicates, making debugging more focused and efficient.",
            "keyPoints": [
              "spy/1 sets spy points on predicates",
              "nospy/1 removes spy points",
              "nospyall/0 removes all spy points",
              "More efficient than full trace"
            ]
          },
          {
            "title": "Spy Point Usage",
            "content": "Setting spy points on specific predicates helps focus debugging on problematic areas.",
            "codeExample": {
              "language": "prolog",
              "code": "?- spy(ancestor/2).\n?- ancestor(john, alice).\n   Spy point on ancestor/2\n   Call: (7) ancestor(john, alice) ? creep",
              "explanation": "Spy point stops execution when the ancestor/2 predicate is called, allowing focused debugging."
            }
          }
        ]
      },
      "resources": [
        {
          "name": "Spy Points Tutorial",
          "type": "tutorial",
          "url": "#",
          "description": "Step-by-step tutorial on using spy points"
        }
      ],
      "exercises": [
        {
          "type": "coding",
          "question": "Set a spy point on the parent/2 predicate and run a query that uses it. What happens?",
          "hint": "Use spy(parent/2) and then run a query involving parent",
          "solution": "?- spy(parent/2).\n?- ancestor(john, alice).\n% Execution will stop at parent/2 calls",
          "explanation": "Setting spy on parent/2 will cause execution to stop whenever parent/2 is called, allowing you to inspect the call."
        }
      ]
    },
    {
      "id": 4,
      "title": "3.4 Common Debugging Techniques",
      "type": "practice",
      "duration": "45 minutes",
      "order": 4,
      "content": {
        "overview": "Learning common debugging techniques and strategies for Prolog programs",
        "sections": [
          {
            "title": "Debugging Recursive Programs",
            "content": "Recursive programs can be tricky to debug. Understanding the recursion depth and base cases is crucial.",
            "keyPoints": [
              "Check base cases first",
              "Verify recursive cases",
              "Monitor recursion depth",
              "Use trace to follow recursion"
            ]
          },
          {
            "title": "Variable Binding Issues",
            "content": "Problems with variable binding are common in Prolog. Understanding when and how variables are bound is essential.",
            "keyPoints": [
              "Variables are bound during unification",
              "Check for unexpected variable bindings",
              "Use write/1 to inspect variables",
              "Verify predicate arguments"
            ]
          },
          {
            "title": "Logic Errors",
            "content": "Logic errors in rules can cause unexpected behavior. Systematic testing helps identify these issues.",
            "keyPoints": [
              "Test rules with simple cases",
              "Verify rule logic step by step",
              "Check for missing conditions",
              "Use test cases systematically"
            ]
          }
        ]
      },
      "resources": [
        {
          "name": "Debugging Checklist",
          "type": "reference",
          "url": "#",
          "description": "Systematic checklist for debugging Prolog programs"
        }
      ],
      "exercises": [
        {
          "type": "coding",
          "question": "Debug the following faulty rule: sibling(X, Y) :- parent(Z, X), parent(Z, Y). What's wrong and how do you fix it?",
          "hint": "Consider what happens when X and Y are the same person",
          "solution": "% Problem: allows X to be sibling of itself\n% Fix: add X \\= Y condition\nsibling(X, Y) :- parent(Z, X), parent(Z, Y), X \\= Y.",
          "explanation": "The original rule allows a person to be their own sibling. Adding X \\= Y prevents this logical error."
        }
      ]
    },
    {
      "id": 5,
      "title": "3.5 Practical Debugging Session",
      "type": "practice",
      "duration": "40 minutes",
      "order": 5,
      "content": {
        "overview": "Hands-on debugging session with real Prolog programs",
        "sections": [
          {
            "title": "Debugging a Family Tree Program",
            "content": "Working through debugging a complex family tree program with multiple rules and relationships.",
            "codeExample": {
              "language": "prolog",
              "code": "% Buggy family tree program\nparent(john, mary).\nparent(john, tom).\nparent(susan, mary).\nparent(susan, tom).\n\n% Buggy rules\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- ancestor(X, Z), parent(Z, Y).\nsibling(X, Y) :- parent(Z, X), parent(Z, Y).",
              "explanation": "This program has several bugs: ancestor rule order issue and missing X \\= Y in sibling rule."
            }
          },
          {
            "title": "Step-by-Step Debugging",
            "content": "Systematic approach to finding and fixing bugs in the family tree program.",
            "keyPoints": [
              "Test each rule individually",
              "Use trace to follow execution",
              "Identify the source of bugs",
              "Fix bugs systematically"
            ]
          }
        ]
      },
      "resources": [
        {
          "name": "Debugging Workshop",
          "type": "workshop",
          "url": "#",
          "description": "Interactive debugging workshop with real examples"
        }
      ],
      "exercises": [
        {
          "type": "coding",
          "question": "Debug the family tree program. What bugs do you find and how do you fix them?",
          "hint": "Test the ancestor and sibling rules with various queries",
          "solution": "% Fixed version\nancestor(X, Y) :- parent(X, Y).\nancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).\nsibling(X, Y) :- parent(Z, X), parent(Z, Y), X \\= Y.",
          "explanation": "Main bugs: ancestor rule had wrong order (should be parent(X,Z), ancestor(Z,Y) not ancestor(X,Z), parent(Z,Y)), and sibling rule was missing X \\= Y condition."
        }
      ]
    }
  ],
  "assessment": {
    "quiz": {
      "questions": [
        {
          "id": 1,
          "type": "multiple_choice",
          "question": "What does the trace command do in Prolog?",
          "options": [
            "Compiles the program",
            "Shows step-by-step execution of queries",
            "Optimizes the program",
            "Creates documentation"
          ],
          "correct": 1,
          "points": 2
        },
        {
          "id": 2,
          "type": "multiple_choice",
          "question": "What is the main advantage of using spy points over full trace?",
          "options": [
            "Spy points are faster",
            "Spy points allow selective debugging of specific predicates",
            "Spy points work with all Prolog systems",
            "Spy points don't require debugging"
          ],
          "correct": 1,
          "points": 2
        },
        {
          "id": 3,
          "type": "true_false",
          "question": "When a Prolog goal fails, the program immediately terminates.",
          "correct": false,
          "points": 1
        },
        {
          "id": 4,
          "type": "multiple_choice",
          "question": "What is a common bug in recursive Prolog rules?",
          "options": [
            "Using too many variables",
            "Wrong order of goals in the rule body",
            "Using uppercase letters",
            "Missing semicolons"
          ],
          "correct": 1,
          "points": 2
        }
      ],
      "totalPoints": 7,
      "passingScore": 4
    }
  },
  "resources": {
    "readings": [
      {
        "title": "Prolog Debugging Techniques",
        "author": "Todd Kelley",
        "type": "course_notes",
        "url": "#",
        "description": "Comprehensive guide to debugging Prolog programs"
      }
    ],
    "videos": [
      {
        "title": "Debugging with Trace and Spy",
        "duration": "25 minutes",
        "url": "#",
        "description": "Demonstration of trace and spy debugging techniques"
      }
    ],
    "tools": [
      {
        "name": "Prolog Debugging Environment",
        "type": "programming",
        "url": "#",
        "description": "Online environment with debugging tools"
      }
    ]
  },
  "prerequisites": [2],
  "nextChapter": 4
}
