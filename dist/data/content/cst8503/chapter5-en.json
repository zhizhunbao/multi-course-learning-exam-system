{
  "courseId": "cst8503",
  "chapterId": 5,
  "title": "Chapter 5: Prolog Lists, Operations, and Arithmetic",
  "description": "Learning to work with lists in Prolog, including list operations, arithmetic operations, and practical applications",
  "duration": "3.5 hours",
  "difficulty": "Intermediate",
  "lastUpdated": "2025-01-16",
  "learningObjectives": [
    "Understand Prolog list syntax and representation",
    "Master basic list operations (head, tail, append)",
    "Learn recursive list processing techniques",
    "Understand arithmetic operations in Prolog",
    "Practice building complex list-processing programs"
  ],
  "lessons": [
    {
      "id": 1,
      "title": "5.1 Introduction to Lists",
      "type": "theory",
      "duration": "35 minutes",
      "order": 1,
      "content": {
        "overview": "Introduction to Prolog lists, their syntax, and basic concepts",
        "sections": [
          {
            "title": "List Syntax",
            "content": "Lists in Prolog are represented as [element1, element2, ...] or using the head-tail notation [Head|Tail].",
            "keyPoints": [
              "Square bracket notation: [a, b, c]",
              "Head-tail notation: [Head|Tail]",
              "Empty list: []",
              "Lists can contain any terms"
            ]
          },
          {
            "title": "List Structure",
            "content": "Lists are internally represented as nested structures using the '.' functor, but this is usually hidden from the programmer.",
            "keyPoints": [
              "Internal representation uses '.' functor",
              "Usually hidden from programmer",
              "Head-tail notation is preferred",
              "Lists are recursive data structures"
            ]
          },
          {
            "title": "List Examples",
            "content": "Various examples of lists and their representations.",
            "codeExample": {
              "language": "prolog",
              "code": "% Different list representations\n[].\n[a].\n[a, b, c].\n[1, 2, 3, 4, 5].\n[apple, banana, orange].\n\n% Head-tail notation\n[a|[]].\n[a|[b, c]].\n[a, b|[c, d]].\n\n% Mixed notation\n[a, b|Rest].\n[First, Second|Tail].",
              "explanation": "These examples show different ways to represent lists, from simple element lists to head-tail notation with variables."
            }
          }
        ]
      },
      "resources": [
        {
          "name": "List Syntax Reference",
          "type": "reference",
          "url": "#",
          "description": "Complete reference for Prolog list syntax"
        }
      ],
      "exercises": [
        {
          "type": "multiple_choice",
          "question": "What is the head of the list [a, b, c]?",
          "options": ["[b, c]", "a", "b", "c"],
          "correct": 1,
          "explanation": "The head of a list is its first element. In [a, b, c], the head is 'a'."
        }
      ]
    },
    {
      "id": 2,
      "title": "5.2 Basic List Operations",
      "type": "practice",
      "duration": "45 minutes",
      "order": 2,
      "content": {
        "overview": "Learning fundamental list operations including head, tail, length, and membership",
        "sections": [
          {
            "title": "Head and Tail Operations",
            "content": "Extracting the head and tail of a list using pattern matching.",
            "keyPoints": [
              "Head is the first element",
              "Tail is the rest of the list",
              "Use pattern matching [H|T]",
              "Empty list has no head"
            ]
          },
          {
            "title": "List Length",
            "content": "Computing the length of a list using recursive rules.",
            "codeExample": {
              "language": "prolog",
              "code": "% Length of a list\nlength([], 0).\nlength([_|Tail], N) :-\n    length(Tail, M),\n    N is M + 1.\n\n% Usage examples\n% ?- length([a, b, c], X).\n% X = 3\n% ?- length([], X).\n% X = 0",
              "explanation": "The length rule uses recursion: empty list has length 0, non-empty list has length 1 + length of tail."
            }
          },
          {
            "title": "List Membership",
            "content": "Checking if an element is a member of a list.",
            "codeExample": {
              "language": "prolog",
              "code": "% Membership in a list\nmember(X, [X|_]).\nmember(X, [_|Tail]) :- member(X, Tail).\n\n% Usage examples\n% ?- member(b, [a, b, c]).\n% true\n% ?- member(X, [a, b, c]).\n% X = a ; X = b ; X = c",
              "explanation": "The member rule checks if X is the head of the list, or recursively checks if X is in the tail."
            }
          }
        ]
      },
      "resources": [
        {
          "name": "List Operations Practice",
          "type": "exercise",
          "url": "#",
          "description": "Practice exercises for basic list operations"
        }
      ],
      "exercises": [
        {
          "type": "coding",
          "question": "Write a rule to find the last element of a list.",
          "hint": "Use recursion: last element of [X] is X, last element of [_|Tail] is last element of Tail",
          "solution": "last([X], X).\nlast([_|Tail], X) :- last(Tail, X).",
          "explanation": "The last rule finds the last element: if list has one element, that's the last; otherwise, find the last element of the tail."
        }
      ]
    },
    {
      "id": 3,
      "title": "5.3 List Concatenation and Manipulation",
      "type": "practice",
      "duration": "50 minutes",
      "order": 3,
      "content": {
        "overview": "Learning to concatenate lists and perform other list manipulation operations",
        "sections": [
          {
            "title": "List Concatenation (Append)",
            "content": "The append operation combines two lists into one.",
            "keyPoints": [
              "append/3 predicate",
              "append(List1, List2, Result)",
              "Can be used in multiple directions",
              "Fundamental list operation"
            ]
          },
          {
            "title": "Append Implementation",
            "content": "How to implement append using recursive rules.",
            "codeExample": {
              "language": "prolog",
              "code": "% Append implementation\nappend([], List, List).\nappend([Head|Tail1], List2, [Head|Result]) :-\n    append(Tail1, List2, Result).\n\n% Usage examples\n% ?- append([a, b], [c, d], X).\n% X = [a, b, c, d]\n% ?- append(X, [c, d], [a, b, c, d]).\n% X = [a, b]\n% ?- append([a, b], X, [a, b, c, d]).\n% X = [c, d]",
              "explanation": "Append works recursively: appending empty list to any list gives that list; appending [H|T] to L gives [H|Result] where Result is T appended to L."
            }
          },
          {
            "title": "List Reversal",
            "content": "Reversing a list using append or accumulator technique.",
            "codeExample": {
              "language": "prolog",
              "code": "% Reverse using append (inefficient)\nreverse([], []).\nreverse([Head|Tail], Result) :-\n    reverse(Tail, ReversedTail),\n    append(ReversedTail, [Head], Result).\n\n% Reverse using accumulator (efficient)\nreverse_acc([], Acc, Acc).\nreverse_acc([Head|Tail], Acc, Result) :-\n    reverse_acc(Tail, [Head|Acc], Result).\n\nreverse(List, Result) :-\n    reverse_acc(List, [], Result).",
              "explanation": "Two approaches to reversing: using append (simple but inefficient) and using accumulator (efficient but more complex)."
            }
          }
        ]
      },
      "resources": [
        {
          "name": "List Manipulation Exercises",
          "type": "exercise",
          "url": "#",
          "description": "Practice exercises for list concatenation and manipulation"
        }
      ],
      "exercises": [
        {
          "type": "coding",
          "question": "Write a rule to remove all occurrences of an element from a list.",
          "hint": "Use recursion: if head equals element, skip it; otherwise, keep it",
          "solution": "remove(_, [], []).\nremove(X, [X|Tail], Result) :- remove(X, Tail, Result).\nremove(X, [Y|Tail], [Y|Result]) :- X \\= Y, remove(X, Tail, Result).",
          "explanation": "Remove works recursively: empty list stays empty; if head equals element, skip it; otherwise, keep head and remove element from tail."
        }
      ]
    },
    {
      "id": 4,
      "title": "5.4 Arithmetic Operations",
      "type": "practice",
      "duration": "40 minutes",
      "order": 4,
      "content": {
        "overview": "Learning arithmetic operations and numeric computations in Prolog",
        "sections": [
          {
            "title": "Arithmetic Operators",
            "content": "Prolog provides standard arithmetic operators: +, -, *, /, mod, and others.",
            "keyPoints": [
              "Standard operators: +, -, *, /",
              "Modulo: mod",
              "Power: **",
              "Comparison: <, >, =<, >=, =:=, =\\="
            ]
          },
          {
            "title": "Arithmetic Evaluation",
            "content": "Arithmetic expressions are evaluated using the 'is' operator, not during unification.",
            "keyPoints": [
              "Use 'is' for arithmetic evaluation",
              "Right side must be ground",
              "Left side gets bound to result",
              "Examples: X is 3 + 4, Y is 10 mod 3"
            ]
          },
          {
            "title": "Arithmetic Examples",
            "content": "Examples of arithmetic operations and their usage.",
            "codeExample": {
              "language": "prolog",
              "code": "% Basic arithmetic\nX is 3 + 4.        % X = 7\nY is 10 - 3.       % Y = 7\nZ is 2 * 5.        % Z = 10\nW is 15 / 3.       % W = 5\nR is 10 mod 3.     % R = 1\n\n% Arithmetic in rules\nsum([], 0).\nsum([Head|Tail], Total) :-\n    sum(Tail, TailSum),\n    Total is Head + TailSum.\n\n% Comparison\nmax(X, Y, X) :- X >= Y.\nmax(X, Y, Y) :- X < Y.",
              "explanation": "These examples show basic arithmetic operations and how to use them in rules for computations like summing lists and finding maximum values."
            }
          }
        ]
      },
      "resources": [
        {
          "name": "Arithmetic Reference",
          "type": "reference",
          "url": "#",
          "description": "Complete reference for Prolog arithmetic operations"
        }
      ],
      "exercises": [
        {
          "type": "coding",
          "question": "Write a rule to calculate the average of a list of numbers.",
          "hint": "Calculate sum and length, then divide sum by length",
          "solution": "average(List, Average) :-\n    sum(List, Sum),\n    length(List, Length),\n    Length > 0,\n    Average is Sum / Length.",
          "explanation": "The average rule calculates the sum and length of the list, then divides the sum by the length to get the average."
        }
      ]
    },
    {
      "id": 5,
      "title": "5.5 Advanced List Processing",
      "type": "practice",
      "duration": "45 minutes",
      "order": 5,
      "content": {
        "overview": "Advanced list processing techniques and complex list operations",
        "sections": [
          {
            "title": "List Sorting",
            "content": "Implementing sorting algorithms for lists using Prolog.",
            "keyPoints": [
              "Bubble sort implementation",
              "Insertion sort implementation",
              "Quicksort implementation",
              "Comparison of algorithms"
            ]
          },
          {
            "title": "List Permutations",
            "content": "Generating all permutations of a list.",
            "codeExample": {
              "language": "prolog",
              "code": "% Generate all permutations\npermutation([], []).\npermutation(List, [Head|PermTail]) :-\n    select(Head, List, Rest),\n    permutation(Rest, PermTail).\n\n% Select an element from list\nselect(X, [X|Tail], Tail).\nselect(X, [Y|Tail], [Y|Rest]) :-\n    select(X, Tail, Rest).",
              "explanation": "Permutation generates all possible arrangements: empty list has one permutation (itself); non-empty list permutations are all elements as head with permutations of remaining elements."
            }
          },
          {
            "title": "List Sublists",
            "content": "Finding sublists and subsequences in lists.",
            "codeExample": {
              "language": "prolog",
              "code": "% Check if one list is sublist of another\nsublist(Sublist, List) :-\n    append(_, Rest, List),\n    append(Sublist, _, Rest).\n\n% Find all sublists\nall_sublists(List, Sublist) :-\n    append(_, Rest, List),\n    append(Sublist, _, Rest).",
              "explanation": "Sublist checks if one list appears as a contiguous subsequence in another list using append operations."
            }
          }
        ]
      },
      "resources": [
        {
          "name": "Advanced List Processing",
          "type": "project",
          "url": "#",
          "description": "Complex list processing project with multiple algorithms"
        }
      ],
      "exercises": [
        {
          "type": "coding",
          "question": "Write a rule to find the longest increasing subsequence in a list of numbers.",
          "hint": "Use recursion to build sequences and track the longest one",
          "solution": "longest_increasing([], []).\nlongest_increasing([X], [X]).\nlongest_increasing([X, Y|Rest], Result) :-\n    X < Y,\n    longest_increasing([Y|Rest], TailResult),\n    Result = [X|TailResult].\nlongest_increasing([X, Y|Rest], Result) :-\n    X >= Y,\n    longest_increasing([Y|Rest], Result).",
          "explanation": "The rule finds the longest increasing subsequence by recursively building sequences where each element is greater than the previous one."
        }
      ]
    }
  ],
  "assessment": {
    "quiz": {
      "questions": [
        {
          "id": 1,
          "type": "multiple_choice",
          "question": "What is the tail of the list [a, b, c]?",
          "options": ["a", "[b, c]", "b", "c"],
          "correct": 1,
          "points": 2
        },
        {
          "id": 2,
          "type": "multiple_choice",
          "question": "Which operator is used for arithmetic evaluation in Prolog?",
          "options": ["=", "is", "==", "eval"],
          "correct": 1,
          "points": 2
        },
        {
          "id": 3,
          "type": "true_false",
          "question": "The append operation can be used to split a list into two parts.",
          "correct": true,
          "points": 1
        },
        {
          "id": 4,
          "type": "multiple_choice",
          "question": "What does the query ?- append([a, b], X, [a, b, c, d]). return?",
          "options": ["X = [c, d]", "X = [a, b]", "X = [a, b, c, d]", "false"],
          "correct": 0,
          "points": 2
        }
      ],
      "totalPoints": 7,
      "passingScore": 4
    }
  },
  "resources": {
    "readings": [
      {
        "title": "Prolog Lists and Arithmetic",
        "author": "Todd Kelley",
        "type": "course_notes",
        "url": "#",
        "description": "Comprehensive guide to Prolog lists and arithmetic operations"
      }
    ],
    "videos": [
      {
        "title": "List Processing in Prolog",
        "duration": "35 minutes",
        "url": "#",
        "description": "Demonstration of list operations and arithmetic in Prolog"
      }
    ],
    "tools": [
      {
        "name": "List Processing Environment",
        "type": "programming",
        "url": "#",
        "description": "Online environment for practicing list operations"
      }
    ]
  },
  "prerequisites": [4],
  "nextChapter": 6
}
